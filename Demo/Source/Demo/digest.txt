Directory structure:
└── Demo/
    ├── Demo.Build.cs
    ├── Demo.cpp
    ├── Demo.h
    ├── Private/
    │   ├── ActionEntryWidget.cpp
    │   ├── BattleActions.cpp
    │   ├── BattleWidget.cpp
    │   ├── CombatComponent.cpp
    │   ├── DemoGameMode.cpp
    │   ├── FloatingTextWidget.cpp
    │   ├── HexAnimationManager.cpp
    │   ├── HexEnemyPawn.cpp
    │   ├── HexGridManager.cpp
    │   ├── HexPathFinder.cpp
    │   ├── HexPawn.cpp
    │   ├── HexSpriteComponent.cpp
    │   ├── HexTile.cpp
    │   ├── LoadoutEditorWidget.cpp
    │   ├── PathView.cpp
    │   └── PlayerStatsWidget.cpp
    └── Public/
        ├── ActionDragOperation.h
        ├── ActionEntryWidget.h
        ├── BattleActions.h
        ├── BattleWidget.h
        ├── CombatComponent.h
        ├── DemoGameMode.h
        ├── EnemyDefinition.h
        ├── FloatingTextWidget.h
        ├── HexAnimationManager.h
        ├── HexAnimationTypes.h
        ├── HexCoordinates.h
        ├── HexEnemyPawn.h
        ├── HexGridManager.h
        ├── HexPathFinder.h
        ├── HexPawn.h
        ├── HexSpriteComponent.h
        ├── HexTile.h
        ├── LoadoutEditorWidget.h
        ├── PathView.h
        └── PlayerStatsWidget.h

================================================
FILE: Demo.Build.cs
================================================
// Fill out your copyright notice in the Description page of Project Settings.
using UnrealBuildTool;

public class Demo : ModuleRules
{
    public Demo(ReadOnlyTargetRules Target) : base(Target)
    {
        // OBLIGATOIRE pour UE5 - Active IWYU et PCH partagÃ©s
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

        // Modules publics essentiels pour ActorComponents
        PublicDependencyModuleNames.AddRange(new string[] {
    "Core", "CoreUObject", "Engine", "InputCore", "UMG", "Slate", "SlateCore", "Paper2D"
});

        // Modules privÃ©s pour fonctionnalitÃ©s avancÃ©es
        PrivateDependencyModuleNames.AddRange(new string[]
        {
            "Slate",
            "SlateCore"
        });

        // FIX pour UE5.6 : Force C++20 et dÃ©sactive IWYU strict
        CppStandard = CppStandardVersion.Cpp20;
        bEnforceIWYU = false;
    }
}


================================================
FILE: Demo.cpp
================================================
// Fill out your copyright notice in the Description page of Project Settings.

#include "Demo.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, Demo, "Demo" );



================================================
FILE: Demo.h
================================================
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"




================================================
FILE: Private/ActionEntryWidget.cpp
================================================
#include "ActionEntryWidget.h"
#include "Components/TextBlock.h"
#include "BattleActions.h"
#include "ActionDragOperation.h"
#include "Blueprint/WidgetBlueprintLibrary.h"  // DetectDragIfPressed
#include "InputCoreTypes.h"                    // EKeys

UActionEntryWidget::UActionEntryWidget(const FObjectInitializer& O) : Super(O) {}

void UActionEntryWidget::NativeConstruct()
{
    Super::NativeConstruct();
    if (Action == EBattleAction::None && DefaultAction != EBattleAction::None)
        Action = DefaultAction;
    RefreshLabel();
}

void UActionEntryWidget::RefreshLabel()
{
    if (Label) Label->SetText(UBattleActionLibrary::ActionToText(Action));
}

FReply UActionEntryWidget::NativeOnPreviewMouseButtonDown(const FGeometry& Geo, const FPointerEvent& E)
{
    if (E.GetEffectingButton() == EKeys::LeftMouseButton)
        return UWidgetBlueprintLibrary::DetectDragIfPressed(E, this, EKeys::LeftMouseButton).NativeReply;
    return Super::NativeOnPreviewMouseButtonDown(Geo, E);
}

void UActionEntryWidget::NativeOnDragDetected(const FGeometry& Geo, const FPointerEvent& E, UDragDropOperation*& OutOp)
{
    Super::NativeOnDragDetected(Geo, E, OutOp);

    auto* Op = NewObject<UDragDropOperation>(this);
    Op->Pivot = EDragPivot::MouseDown;

    // Use a proxy visual that does NOT block hit tests
    UActionEntryWidget* Proxy = CreateWidget<UActionEntryWidget>(GetWorld(), GetClass());
    if (Proxy)
    {
        // copy minimal visuals
        if (Proxy->Label && Label) Proxy->Label->SetText(Label->GetText());
        Proxy->SetIsEnabled(false);
        Proxy->SetVisibility(ESlateVisibility::HitTestInvisible);
        Op->DefaultDragVisual = Proxy;
    }
    else
    {
        // fallback: use self but make it hit-test-invisible during drag
        SetVisibility(ESlateVisibility::HitTestInvisible);
        Op->DefaultDragVisual = this;
    }

    OutOp = Op;
}

void UActionEntryWidget::NativeOnDragCancelled(const FDragDropEvent& Ev, UDragDropOperation* Op)
{
    Super::NativeOnDragCancelled(Ev, Op);
    SetVisibility(ESlateVisibility::Visible);
}

bool UActionEntryWidget::NativeOnDrop(const FGeometry& Geo, const FDragDropEvent& Ev, UDragDropOperation* Op)
{
    SetVisibility(ESlateVisibility::Visible);
    return Super::NativeOnDrop(Geo, Ev, Op);
}



================================================
FILE: Private/BattleActions.cpp
================================================
#include "BattleActions.h"  // no extra code needed



================================================
FILE: Private/BattleWidget.cpp
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x90 in position 7881: character maps to <undefined>


================================================
FILE: Private/CombatComponent.cpp
================================================
#include "CombatComponent.h"
#include "BattleActions.h"
#include "Math/UnrealMathUtility.h"

UCombatComponent::UCombatComponent()
{
    PrimaryComponentTick.bCanEverTick = false;
	
	// defaults (can be overridden in BP defaults)
    Stats.Level = 1; Stats.MaxHP = 30; Stats.HP = 30;
    Stats.Attack = 20; Stats.Defense = 3; Stats.XP = 0; Stats.XPToNext = 50;

    MaxSlots = 5;
    Loadout.Init(FBattleActionSlot{}, MaxSlots);
    Loadout[0].Action = EBattleAction::Attack;
    Loadout[1].Action = EBattleAction::Attack;
    Loadout[2].Action = EBattleAction::Heal;
    Loadout[3].Action = EBattleAction::Attack;
    Loadout[4].Action = EBattleAction::Attack;
}

void UCombatComponent::BeginPlay()
{
    Super::BeginPlay();
    if (Loadout.Num() != MaxSlots) Loadout.SetNum(MaxSlots);
    for (auto& S : Loadout) if (S.SlotCost <= 0) S.SlotCost = 1;
}


void UCombatComponent::AddXP(int32 Amount)
{
    if (Amount <= 0) return;
    Stats.XP += Amount;
    TryLevelUp();
}

void UCombatComponent::SetLoadout(const TArray<FBattleActionSlot>& In)
{
    Loadout = In;
    if (Loadout.Num() != MaxSlots) Loadout.SetNum(MaxSlots);
}

void UCombatComponent::ApplyDamage(int32 RawDamage)
{
    const int32 dmg = FMath::Max(0, RawDamage - (Stats.Defense / 2));
    Stats.HP = FMath::Clamp(Stats.HP - dmg, 0, Stats.MaxHP);
}

void UCombatComponent::Heal(int32 Amount)
{
    if (Amount <= 0) return;
    Stats.HP = FMath::Clamp(Stats.HP + Amount, 0, Stats.MaxHP);
}

void UCombatComponent::TryLevelUp()
{
    while (Stats.XP >= Stats.XPToNext)
    {
        Stats.XP -= Stats.XPToNext;
        Stats.Level += 1;
        Stats.MaxHP += 5;
        Stats.Attack += 2;
        Stats.Defense += 1;
        Stats.HP = Stats.MaxHP;
        Stats.XPToNext = FMath::RoundToInt(Stats.XPToNext * 1.25f);
    }
}

void UCombatComponent::SetSlotAction(int32 Index, EBattleAction Action, int32 Cost)
{
    if (Cost <= 0) Cost = 1;
    if (Loadout.Num() != MaxSlots) Loadout.SetNum(MaxSlots);
    if (!Loadout.IsValidIndex(Index)) return;
    Loadout[Index].Action  = Action;
    Loadout[Index].SlotCost = Cost;
}



================================================
FILE: Private/DemoGameMode.cpp
================================================
// DemoGameMode.cpp
#include "DemoGameMode.h"
#include "Blueprint/UserWidget.h"
#include "Algo/Reverse.h"
#include "Engine/World.h"
#include "GameFramework/PlayerController.h"
#include "Kismet/GameplayStatics.h"
#include "TimerManager.h"
#include "Engine/Texture2D.h"
#include "UObject/ConstructorHelpers.h"

#include "BattleWidget.h"
#include "HexAnimationManager.h"
#include "HexGridManager.h"
#include "HexPathFinder.h"
#include "HexPawn.h"
#include "HexTile.h"
#include "PathView.h"
#include "PlayerStatsWidget.h"
#include "LoadoutEditorWidget.h"
#include "HexEnemyPawn.h" // <-- required
#include "EnemyDefinition.h"
#include "BattleWidget.h"
#include "Engine/Texture2D.h"

namespace
{
    constexpr float kSnapRetryPeriodSec = 0.05f;
    constexpr float kPreviewThrottleSec = 0.10f;
}

namespace HexBridge
{
    /** BFS across existing tiles to bridge non-adjacent steps */
    static bool BuildBridge(UHexGridManager *GM,
                            const FHexAxialCoordinates &From,
                            const FHexAxialCoordinates &To,
                            TArray<FHexAxialCoordinates> &OutChain)
    {
        if (!GM)
            return false;
        if (From == To)
        {
            OutChain.Reset();
            return true;
        }

        TQueue<FHexAxialCoordinates> Open;
        TMap<FHexAxialCoordinates, FHexAxialCoordinates> Parent;

        Open.Enqueue(From);
        Parent.Add(From, From);

        bool bFound = false;
        FHexAxialCoordinates Cur;

        while (Open.Dequeue(Cur))
        {
            const TArray<FHexAxialCoordinates> Neigh = GM->GetNeighbors(Cur);
            for (const FHexAxialCoordinates &N : Neigh)
            {
                if (Parent.Contains(N))
                    continue;
                Parent.Add(N, Cur);
                if (N == To)
                {
                    bFound = true;
                    Cur = N;
                    break;
                }
                Open.Enqueue(N);
            }
            if (bFound)
                break;
        }

        if (!bFound)
            return false;

        TArray<FHexAxialCoordinates> Chain;
        for (FHexAxialCoordinates C = Cur; !(C == From); C = Parent[C])
        {
            Chain.Add(C);
        }
        Algo::Reverse(Chain);
        OutChain = MoveTemp(Chain);
        return true;
    }

    /** Enforce adjacency by inserting intermediate tiles using BFS on existing tiles */
    static void BridgePathUsingExistingTiles(UHexGridManager *GM, TArray<FHexAxialCoordinates> &Path)
    {
        if (!GM || Path.Num() < 2)
            return;

        TArray<FHexAxialCoordinates> Out;
        Out.Reserve(Path.Num() * 2);
        Out.Add(Path[0]);

        for (int32 i = 1; i < Path.Num(); ++i)
        {
            const FHexAxialCoordinates From = Out.Last();
            const FHexAxialCoordinates To = Path[i];

            const bool bAdjacent = GM->GetNeighbors(From).Contains(To);
            if (bAdjacent)
            {
                Out.Add(To);
                continue;
            }

            TArray<FHexAxialCoordinates> Bridge;
            if (BuildBridge(GM, From, To, Bridge) && Bridge.Num() > 0)
            {
                Out.Append(Bridge);
            }
            else
            {
                UE_LOG(LogTemp, Warning, TEXT("[Bridge] Impossible de relier (%d,%d)->(%d,%d) via voisins â€” saut ignorÃ©"),
                       From.Q, From.R, To.Q, To.R);
            }
        }

        Path = MoveTemp(Out);
    }
}

namespace Hex
{
    /** Doubled-Q neighbor deltas */
    static const FHexAxialCoordinates NeighborDirs[6] =
        {
            {+2, 0}, {+1, -1}, {-1, -1}, {-2, 0}, {-1, +1}, {+1, +1}};

    static int32 HexDistance(const FHexAxialCoordinates &A, const FHexAxialCoordinates &B)
    {
        const int32 dq = FMath::Abs(A.Q - B.Q);
        const int32 dr = FMath::Abs(A.R - B.R);
        const int32 diag = FMath::Min(dq / 2, dr);
        const int32 remQ = dq - diag * 2;
        const int32 remR = dr - diag;
        return diag + remR + remQ / 2;
    }

    static bool AreNeighbors(const FHexAxialCoordinates &A, const FHexAxialCoordinates &B)
    {
        for (const auto &D : NeighborDirs)
        {
            if (A.Q + D.Q == B.Q && A.R + D.R == B.R)
                return true;
        }
        return false;
    }

    static FHexAxialCoordinates StepToward(const FHexAxialCoordinates &From, const FHexAxialCoordinates &To)
    {
        int32 BestIdx = 0;
        int32 BestDist = TNumericLimits<int32>::Max();
        for (int32 i = 0; i < 6; ++i)
        {
            FHexAxialCoordinates C{From.Q + NeighborDirs[i].Q, From.R + NeighborDirs[i].R};
            const int32 Dist = HexDistance(C, To);
            if (Dist < BestDist)
            {
                BestDist = Dist;
                BestIdx = i;
            }
        }
        return {From.Q + NeighborDirs[BestIdx].Q, From.R + NeighborDirs[BestIdx].R};
    }

    /** Expand a path by inserting steps until all hops are adjacent (guarded) */
    static void SanitizePath(TArray<FHexAxialCoordinates> &Path)
    {
        if (Path.Num() < 2)
            return;

        TArray<FHexAxialCoordinates> Out;
        Out.Reserve(Path.Num() * 2);
        Out.Add(Path[0]);

        for (int32 i = 1; i < Path.Num(); ++i)
        {
            FHexAxialCoordinates Cur = Out.Last();
            const FHexAxialCoordinates Target = Path[i];

            int32 Guard = 0;
            while (!AreNeighbors(Cur, Target) && Guard++ < 64)
            {
                const FHexAxialCoordinates Step = StepToward(Cur, Target);
                Out.Add(Step);
                Cur = Step;
            }
            Out.Add(Target);

#if !UE_BUILD_SHIPPING
            const int32 Jump = HexDistance(Out[Out.Num() - 2], Out.Last());
            if (Jump > 1)
            {
                UE_LOG(LogTemp, Warning, TEXT("[SanitizePath] Jump=%d entre (%d,%d)->(%d,%d)"),
                       Jump, Out[Out.Num() - 2].Q, Out[Out.Num() - 2].R, Out.Last().Q, Out.Last().R);
            }
#endif
        }

        Path = MoveTemp(Out);
    }
}

void ADemoGameMode::PostLogin(APlayerController *NewPlayer)
{
    Super::PostLogin(NewPlayer);

    // Retry until snap succeeds
    GetWorldTimerManager().SetTimer(
        SnapRetryHandle, this, &ADemoGameMode::TrySnapPawnOnce,
        kSnapRetryPeriodSec, /*bLoop=*/true, /*FirstDelay=*/0.0f);
}

void ADemoGameMode::Logout(AController *Exiting)
{
    if (AHexPawn *Pawn = Cast<AHexPawn>(Exiting->GetPawn()))
    {
        if (AnimationManager)
        {
            AnimationManager->UnregisterPlayer(Pawn);
        }
    }
    Super::Logout(Exiting);
}

ADemoGameMode::ADemoGameMode()
{
    DefaultPawnClass = AHexPawn::StaticClass();

    GridManager = CreateDefaultSubobject<UHexGridManager>(TEXT("HexGridManager"));
    PathFinder = CreateDefaultSubobject<UHexPathFinder>(TEXT("HexPathFinder"));

    static ConstructorHelpers::FClassFinder<AHexTile> TileBP(TEXT("/Game/Blueprints/BP_HexTile"));
    if (TileBP.Succeeded())
    {
        HexTileClass = TileBP.Class;
    }

    static ConstructorHelpers::FObjectFinder<UEnemyDefinition> Gob(
        TEXT("/Game/Datasets/DA_Goblux.DA_Goblux")); // adjust path if different
    if (Gob.Succeeded())
    {
        EnemyCatalog.Add(TEXT("goblux"), Gob.Object);
    }
}

void ADemoGameMode::BeginPlay()
{
    Super::BeginPlay();
    if (APlayerController *PC = GetWorld()->GetFirstPlayerController())
    {
        PC->InputComponent->BindAction("TestBattle", IE_Pressed, this, &ADemoGameMode::StartTestBattle);
    }
    if (!GridManager || !GridManager->IsRegistered())
    {
        GridManager = NewObject<UHexGridManager>(this, TEXT("HexGridManager_RT"));
        AddInstanceComponent(GridManager);
        GridManager->RegisterComponent();
    }
    if (!PathFinder || !PathFinder->IsRegistered())
    {
        PathFinder = NewObject<UHexPathFinder>(this, TEXT("HexPathFinder_RT"));
        AddInstanceComponent(PathFinder);
        PathFinder->RegisterComponent();
    }
    if (PlayerStatsWidgetClass)
    {
        if (UUserWidget *W = CreateWidget<UUserWidget>(GetWorld(), PlayerStatsWidgetClass))
        {
            W->AddToViewport(/*ZOrder*/ 0);
            PlayerStatsWidget = W;

            // wire data source
            if (AHexPawn *P = GetPlayerPawnTyped())
            {
                // If widget is our C++ type, push the Combat component
                if (UPlayerStatsWidget *PSW = Cast<UPlayerStatsWidget>(W))
                {
                    PSW->SetCombat(P->GetCombat());
                }
            }
        }
    }
    EnemyRNG.Initialize(int32(FDateTime::UtcNow().GetTicks() & 0xFFFFFFFF));

    UWorld *W = GetWorld();
    if (!W)
        return;

    const bool bIsGame = (W->IsGameWorld() || W->WorldType == EWorldType::PIE || W->WorldType == EWorldType::Game);
    if (!bIsGame || IsRunningCommandlet() || HasAnyFlags(RF_ClassDefaultObject))
    {
        return;
    }

    if (PathFinder && GridManager)
    {
        PathFinder->Init(GridManager);
        UE_LOG(LogTemp, Warning, TEXT("[PathFinder] Bound Grid=%s"), *GetNameSafe(GridManager));
    }

    // Optional PC override coming from BP
    if (!PCClassSoft.IsNull())
    {
        if (UClass *PCCls = PCClassSoft.LoadSynchronous())
        {
            PlayerControllerClass = PCCls;
        }
    }

    if (APlayerController *PC0 = GetWorld()->GetFirstPlayerController())
    {
        UE_LOG(LogTemp, Warning, TEXT("PC actif: %s"), *PC0->GetClass()->GetName());
    }
    UE_LOG(LogTemp, Warning, TEXT("GM actif: %s"), *GetClass()->GetName());

    APlayerController *OldPC = GetWorld()->GetFirstPlayerController();
    if (OldPC)
    {
        UE_LOG(LogTemp, Warning, TEXT("PC actif: %s (attendu: %s)"),
               *OldPC->GetClass()->GetName(),
               PlayerControllerClass ? *PlayerControllerClass->GetName() : TEXT("(none)"));
    }

    // Replace PC if level did not take the right class
    if (PlayerControllerClass && OldPC && !OldPC->IsA(PlayerControllerClass))
    {
        APawn *Pawn = OldPC->GetPawn();

        FActorSpawnParameters Params;
        Params.Instigator = Pawn;
        Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

        APlayerController *NewPC = GetWorld()->SpawnActor<APlayerController>(
            PlayerControllerClass,
            Pawn ? Pawn->GetActorLocation() : FVector::ZeroVector,
            Pawn ? Pawn->GetActorRotation() : FRotator::ZeroRotator,
            Params);

        if (NewPC)
        {
            RestartPlayer(NewPC);
            if (Pawn)
            {
                OldPC->UnPossess();
                NewPC->Possess(Pawn);
            }
            UE_LOG(LogTemp, Warning, TEXT("PC remplacÃ©: %s -> %s"),
                   *OldPC->GetClass()->GetName(), *NewPC->GetClass()->GetName());
            OldPC->Destroy();
        }
        else
        {
            UE_LOG(LogTemp, Error, TEXT("Echec spawn PlayerControllerClass %s"), *PlayerControllerClass->GetName());
        }
    }

    if (!ensure(GridManager))
    {
        UE_LOG(LogTemp, Error, TEXT("DemoGameMode BeginPlay: GridManager is NULL, aborting grid gen"));
        return;
    }
    if (!ensure(HexTileClass))
    {
        UE_LOG(LogTemp, Error, TEXT("DemoGameMode BeginPlay: HexTileClass is NULL, aborting grid gen"));
        return;
    }

    // Build grid
    GridManager->InitializeGrid(GridRadius, HexTileClass);
    PathFinder->Init(GridManager);

    UE_LOG(LogTemp, Warning, TEXT("DemoGameMode BeginPlay : grille gÃ©nÃ©rÃ©e"));

    // Initial pawn tile
    InitializePawnStartTile(FHexAxialCoordinates(0, 6));

    // Mouse and UI setup
    if (APlayerController *PC = UGameplayStatics::GetPlayerController(this, 0))
    {
        PC->bShowMouseCursor = true;
        PC->bEnableClickEvents = true;
        PC->bEnableMouseOverEvents = true;

        FInputModeGameAndUI Mode;
        Mode.SetHideCursorDuringCapture(false);
        Mode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
        PC->SetInputMode(Mode);
    }

    if (!IsValid(PathView))
    {
        PathView = GetWorld()->SpawnActor<APathView>();
    }

    UE_LOG(LogTemp, Warning, TEXT("PC=%s  Pawn=%s  ViewTarget=%s"),
           *GetNameSafe(GetWorld()->GetFirstPlayerController()),
           *GetNameSafe(GetWorld()->GetFirstPlayerController() ? GetWorld()->GetFirstPlayerController()->GetPawn() : nullptr),
           *GetNameSafe(GetWorld()->GetFirstPlayerController() ? GetWorld()->GetFirstPlayerController()->GetViewTarget() : nullptr));
}

void ADemoGameMode::HandleTileClicked(AHexTile *ClickedTile)
{
    if (!ClickedTile || !GridManager || !PathFinder)
        return;

    // Shop tiles open UI and skip pathfinding
    if (ClickedTile->GetTileType() == EHexTileType::Shop || ClickedTile->bIsShop || ClickedTile->ActorHasTag(TEXT("Shop")))
    {
        OpenShopAt(ClickedTile);
        return;
    }

    AHexPawn *HexP = GetPlayerPawnTyped();
    if (!HexP)
    {
        UE_LOG(LogTemp, Error, TEXT("HandleTileClicked: Pawn n'est pas un AHexPawn"));
        return;
    }

    AHexTile *FromTile = HexP->GetCurrentTile();
    if (!FromTile)
{
    HexP->SetCurrentTile(ClickedTile);
    HexP->SetActorLocation(ClickedTile->GetActorLocation());
    UE_LOG(LogTemp, Warning, TEXT("Affectation initiale -> (%d,%d)"),
           ClickedTile->GetAxialCoordinates().Q, ClickedTile->GetAxialCoordinates().R);

    if (ClickedTile->GetTileType() == EHexTileType::Enemy)
    {
        StartTestBattle();
        // keep tile as Enemy as requested
        // ClickedTile->SetTileType(EHexTileType::Normal); // do NOT reset now
    }
    UpdateReachableVisibility(3);
    return;
}


    const FHexAxialCoordinates Start = FromTile->GetAxialCoordinates();
    const FHexAxialCoordinates Goal = ClickedTile->GetAxialCoordinates();
    if (Start == Goal)
        return;

    UE_LOG(LogTemp, Warning, TEXT("A*: Start=(%d,%d) Goal=(%d,%d)"),
           Start.Q, Start.R, Goal.Q, Goal.R);
    UE_LOG(LogTemp, Warning, TEXT("A*: StartExists=%d GoalExists=%d StartNeigh=%d GoalNeigh=%d"),
           GridManager->GetHexTileAt(Start) != nullptr,
           GridManager->GetHexTileAt(Goal) != nullptr,
           GridManager->GetNeighbors(Start).Num(),
           GridManager->GetNeighbors(Goal).Num());

    TArray<FHexAxialCoordinates> Path = PathFinder->FindPath(Start, Goal);
    HexBridge::BridgePathUsingExistingTiles(GridManager, Path);

    if (Path.Num() == 0)
    {
        UE_LOG(LogTemp, Warning, TEXT("A*: aucun chemin"));
        return;
    }

    HexP->StartPathFollowing(Path, GridManager);
}

void ADemoGameMode::InitializePawnStartTile(const FHexAxialCoordinates &InStartCoords)
{
    if (!GridManager)
    {
        UE_LOG(LogTemp, Error, TEXT("InitializePawnStartTile : GridManager null"));
        return;
    }

    AHexTile *Tile = GridManager->GetHexTileAt(InStartCoords);
    if (!Tile)
    {
        UE_LOG(LogTemp, Error, TEXT("InitializePawnStartTile : pas de tuile Ã  (%d,%d)"),
               InStartCoords.Q, InStartCoords.R);
        return;
    }

    if (AHexPawn *HexP = GetPlayerPawnTyped())
    {
        HexP->SetCurrentTile(Tile);
        UpdateReachableVisibility(3);
        UE_LOG(LogTemp, Warning, TEXT("Pawn dÃ©marrÃ© sur (%d,%d)"),
               InStartCoords.Q, InStartCoords.R);
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("InitializePawnStartTile : pawn non HexPawn"));
    }
}

void ADemoGameMode::ShowPlannedPathTo(AHexTile *GoalTile)
{
    if (!GridManager || !PathFinder || !GoalTile || !PathView)
        return;

    AHexPawn *P = GetPlayerPawnTyped();
    AHexTile *StartTile = P ? P->GetCurrentTile() : nullptr;
    if (!StartTile)
    {
        PathView->Clear();
        return;
    }

    const FHexAxialCoordinates Start = StartTile->GetAxialCoordinates();
    const FHexAxialCoordinates Goal = GoalTile->GetAxialCoordinates();

    TArray<FHexAxialCoordinates> AxialPath = PathFinder->FindPath(Start, Goal);
    if (AxialPath.Num() < 2)
    {
        PathView->Clear();
        return;
    }

    TArray<FVector> Points;
    Points.Reserve(AxialPath.Num());
    for (const auto &C : AxialPath)
        if (AHexTile *T = GridManager->GetHexTileAt(C))
            Points.Add(T->GetActorLocation());

    PathView->Show(Points);
}

void ADemoGameMode::ClearPlannedPath()
{
    if (PathView)
        PathView->Clear();
}

AHexPawn *ADemoGameMode::GetPlayerPawnTyped() const
{
    return Cast<AHexPawn>(UGameplayStatics::GetPlayerPawn(this, 0));
}

void ADemoGameMode::PreviewPathTo(AHexTile *GoalTile)
{
    if (!bPreviewEnabled || !GoalTile)
        return;
    PendingGoal = GoalTile;

    if (!GetWorldTimerManager().IsTimerActive(PreviewThrottle))
    {
        GetWorldTimerManager().SetTimer(PreviewThrottle, this, &ADemoGameMode::DoPreviewTick, kPreviewThrottleSec, false);
    }
}

void ADemoGameMode::DoPreviewTick()
{
    if (!PathView)
        return;

    if (!bPreviewEnabled)
    {
        ClearPreview();
        return;
    }

    UHexGridManager *GM = GetHexGridManager();
    UHexPathFinder *PF = GetHexPathFinder();
    if (!GM || !PF)
        return;

    AHexPawn *P = GetPlayerPawnTyped();
    if (!P)
        return;

    AHexTile *StartTile = P->GetCurrentTile();
    AHexTile *GoalTile = PendingGoal.IsValid() ? PendingGoal.Get() : nullptr;
    if (!StartTile || !GoalTile)
        return;

    const FHexAxialCoordinates Start = StartTile->GetAxialCoordinates();
    const FHexAxialCoordinates Goal = GoalTile->GetAxialCoordinates();

    if (Start == LastStart && Goal == LastGoal)
        return;
    LastStart = Start;
    LastGoal = Goal;

    TArray<FHexAxialCoordinates> AxialPath = PF->FindPath(Start, Goal);
    if (AxialPath.Num() < 2)
    {
        ClearPreview();
        return;
    }

    TArray<FVector> Points;
    Points.Reserve(AxialPath.Num());
    for (const auto &C : AxialPath)
        if (AHexTile *T = GM->GetHexTileAt(C))
            Points.Add(T->GetActorLocation());

    PathView->Show(Points);
}

void ADemoGameMode::ClearPreview()
{
    LastStart = {INT32_MAX, INT32_MAX};
    LastGoal = {INT32_MAX, INT32_MAX};
    if (PathView)
        PathView->Clear();
}

void ADemoGameMode::SetPreviewEnabled(bool bEnabled)
{
    bPreviewEnabled = bEnabled;
    if (!bPreviewEnabled)
        ClearPreview();
}

void ADemoGameMode::TogglePreview()
{
    bPreviewEnabled = !bPreviewEnabled;
    if (!bPreviewEnabled)
        ClearPreview();
}

void ADemoGameMode::OpenShopAt(AHexTile *ShopTile)
{
    if (!ShopTile)
        return;

    if (!ShopWidgetClass)
    {
        UE_LOG(LogTemp, Warning, TEXT("ShopWidgetClass non dÃ©fini"));
        return;
    }

    if (UUserWidget *W = CreateWidget<UUserWidget>(GetWorld(), ShopWidgetClass))
    {
        W->AddToViewport();
        if (APlayerController *PC = UGameplayStatics::GetPlayerController(this, 0))
        {
            PC->bShowMouseCursor = true;
            FInputModeGameAndUI Mode;
            Mode.SetHideCursorDuringCapture(false);
            PC->SetInputMode(Mode);
        }
        ShopWidget = W;
    }
}

void ADemoGameMode::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
    GetWorldTimerManager().ClearTimer(SnapRetryHandle);
    GetWorldTimerManager().ClearTimer(PreviewThrottle);

    if (IsValid(PathView) && !PathView->IsActorBeingDestroyed())
    {
        PathView->Destroy();
        PathView = nullptr;
    }

    if (ShopWidget.IsValid())
    {
        ShopWidget->RemoveFromParent();
        ShopWidget.Reset();
    }

    Super::EndPlay(EndPlayReason);
}

void ADemoGameMode::TrySnapPawnOnce()
{
    if (!GridManager)
        return;

    APlayerController *PC = GetWorld()->GetFirstPlayerController();
    if (!PC)
        return;

    AHexPawn *P = Cast<AHexPawn>(PC->GetPawn());
    if (!P)
        return;

    AHexTile *T = GridManager->GetHexTileAt(StartCoords);
    if (!T)
        return;

    // Snap pawn and camera
    P->SetCurrentTile(T);
    P->SetActorLocation(T->GetActorLocation());
    PC->bAutoManageActiveCameraTarget = false;
    PC->SetViewTarget(P);

    GetWorldTimerManager().ClearTimer(SnapRetryHandle);
    UpdateReachableVisibility(3);
    UE_LOG(LogTemp, Warning, TEXT("Snap OK sur (%d,%d)"), StartCoords.Q, StartCoords.R);
}

void ADemoGameMode::UpdateReachableVisibility(int32 MaxSteps)
{
    if (!GridManager)
        return;

    AHexPawn *P = GetPlayerPawnTyped();
    if (!P)
        return;

    AHexTile *StartTile = P->GetCurrentTile();
    if (!StartTile)
        return;

    const FHexAxialCoordinates Start = StartTile->GetAxialCoordinates();

    // BFS bornÃ© en nombre de pas
    TSet<FHexAxialCoordinates> Visited;
    TMap<FHexAxialCoordinates, int32> Dist;
    TQueue<FHexAxialCoordinates> Q;

    Visited.Add(Start);
    Dist.Add(Start, 0);
    Q.Enqueue(Start);

    while (!Q.IsEmpty())
    {
        FHexAxialCoordinates Cur;
        Q.Dequeue(Cur);
        const int32 D = Dist[Cur];
        if (D >= MaxSteps)
            continue;

        const TArray<FHexAxialCoordinates> Neigh = GridManager->GetNeighbors(Cur);
        for (const FHexAxialCoordinates &N : Neigh)
        {
            if (!Visited.Contains(N))
            {
                Visited.Add(N);
                Dist.Add(N, D + 1);
                Q.Enqueue(N);
            }
        }
    }

    // Parcours de toute la grille via bornes connues
    const int32 R = GridRadius;             // dÃ©jÃ  dans le GameMode
    for (int32 q = -2 * R; q <= 2 * R; ++q) // doubled-q
    {
        for (int32 r = -R; r <= R; ++r)
        {
            if (AHexTile *T = GridManager->GetHexTileAt({q, r}))
            {
                const bool bReachable = Visited.Contains({q, r});
                T->SetActorHiddenInGame(!bReachable);
                T->SetActorEnableCollision(bReachable);
            }
        }
    }
}

void ADemoGameMode::StartTestBattle()
{
    UE_LOG(LogTemp, Warning, TEXT("[Battle] GM=%s  CatalogSize=%d"),
           *GetClass()->GetName(), EnemyCatalog.Num());
    for (const auto &Kvp : EnemyCatalog)
    {
        UE_LOG(LogTemp, Warning, TEXT("[Battle] Catalog key=%s -> asset=%s"),
               *Kvp.Key.ToString(), *GetNameSafe(Kvp.Value.Get()));
    }

    UBattleWidget *W = CreateWidget<UBattleWidget>(GetWorld(), BattleWidgetClass);
    if (!W)
        return;
    W->AddToViewport(20);

    AHexPawn *PlayerPawn = GetPlayerPawnTyped();
    UCombatComponent *PlayerCombat = PlayerPawn ? PlayerPawn->GetCombat() : nullptr;

    // Choose enemy id
    const FName EnemyId = PickRandomEnemyIdFromCatalog();
    if (EnemyId.IsNone())
    {
        UE_LOG(LogTemp, Warning, TEXT("EnemyCatalog empty"));
        return;
    }
    UE_LOG(LogTemp, Warning, TEXT("[Battle] Picked id=%s"), *EnemyId.ToString());
    // Spawn enemy with data BEFORE BeginPlay
    FVector BaseLoc = PlayerPawn ? PlayerPawn->GetActorLocation() : FVector::ZeroVector;
    FTransform X(FRotator::ZeroRotator, BaseLoc + FVector(2000, 0, 0));

    UClass *SpawnClass = EnemyPawnClass ? EnemyPawnClass.Get() : AHexEnemyPawn::StaticClass();
    AHexEnemyPawn *EnemyPawn = GetWorld()->SpawnActorDeferred<AHexEnemyPawn>(SpawnClass, X);
    if (EnemyPawn)
    {
        if (TSoftObjectPtr<UEnemyDefinition> *Entry = EnemyCatalog.Find(EnemyId))
        {
            EnemyPawn->EnemyData = *Entry;

            if (UEnemyDefinition *Def = Entry->LoadSynchronous())
            {
                if (UTexture2D *Tex = Def->Portrait.LoadSynchronous())
                {
                    W->SetEnemyPortrait(Tex);
                }
                W->SetVictoryXP(Def->XPReward);   // <-- pass reward
            }
        }
        else
        {
            UE_LOG(LogTemp, Warning, TEXT("EnemyCatalog has no entry for id=%s"), *EnemyId.ToString());
        }
        UGameplayStatics::FinishSpawningActor(EnemyPawn, X);
        APlayerController *PC = GetWorld()->GetFirstPlayerController();
        if (PC && PlayerPawn)
        {
            PC->bAutoManageActiveCameraTarget = false; // <- replace the bad call
            if (PC->GetPawn() != PlayerPawn)
                PC->Possess(PlayerPawn);
            PC->SetViewTargetWithBlend(PlayerPawn, 0.0f);
            PC->bShowMouseCursor = true;

            FInputModeGameAndUI Mode;
            Mode.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock);
            PC->SetInputMode(Mode);
        }
    }

    W->SetSides(PlayerCombat, EnemyPawn ? EnemyPawn->GetCombat() : nullptr);
}

void ADemoGameMode::OpenLoadoutEditor()
{
    if (!LoadoutWidgetClass)
        return;

    if (ULoadoutEditorWidget *W = CreateWidget<ULoadoutEditorWidget>(GetWorld(), LoadoutWidgetClass))
    {
        W->AddToViewport(15);
        W->SetAlignmentInViewport(FVector2D(0.5f, 0.5f));
        W->SetAnchorsInViewport(FAnchors(0.5f, 0.5f, 0.5f, 0.5f));
        W->SetPositionInViewport(FVector2D(0, 0));
        W->SetDesiredSizeInViewport(FVector2D(700, 480));

        if (AHexPawn *P = GetPlayerPawnTyped())
        {
            W->SetCombat(P->GetCombat());
        }
    }
}

FName ADemoGameMode::PickRandomEnemyIdFromCatalog() const
{
    TArray<FName> Keys;
    EnemyCatalog.GetKeys(Keys);
    if (Keys.Num() == 0)
        return NAME_None;
    const int32 idx = FMath::RandHelper(Keys.Num());
    UE_LOG(LogTemp, Log, TEXT("Catalog keys: %s -> pick[%d]=%s"),
           *FString::JoinBy(Keys, TEXT(","), [](const FName &N)
                            { return N.ToString(); }),
           idx, *Keys[idx].ToString());
    return Keys[idx];
}

void ADemoGameMode::OnPawnArrived(AHexPawn* Pawn)
{
    if (!Pawn) return;
    if (AHexTile* T = Pawn->GetCurrentTile())
    {
        if (T->GetTileType() == EHexTileType::Enemy)
        {
            UE_LOG(LogTemp, Warning, TEXT("[TileEvent] Enemy tile at (%d,%d)"),
                   T->GetAxialCoordinates().Q, T->GetAxialCoordinates().R);
            StartTestBattle();
        }
    }
}


================================================
FILE: Private/FloatingTextWidget.cpp
================================================
#include "FloatingTextWidget.h"
#include "Components/TextBlock.h"
#include "Animation/WidgetAnimationEvents.h"  // add

void UFloatingTextWidget::SetTextAndColor(const FText& T, const FLinearColor& C)
{
    if (Label) { Label->SetText(T); Label->SetColorAndOpacity(C); }
}

void UFloatingTextWidget::PlayAndDie()
{
    if (Pop)
    {
        FWidgetAnimationDynamicEvent End;
        End.BindDynamic(this, &UFloatingTextWidget::OnAnimFinished); // fix
        BindToAnimationFinished(Pop, End);
        PlayAnimation(Pop, 0.f, 1);
    }
    else
    {
        FTimerHandle H;
        GetWorld()->GetTimerManager().SetTimer(H, [this]{ RemoveFromParent(); }, 0.8f, false);
    }
}

void UFloatingTextWidget::OnAnimFinished()
{
    RemoveFromParent();
}



================================================
FILE: Private/HexAnimationManager.cpp
================================================
// HexAnimationManager.cpp
#include "HexAnimationManager.h"
#include "HexPawn.h"  // Add this include

AHexAnimationManager::AHexAnimationManager()
{
    PrimaryActorTick.bCanEverTick = true;
}

void AHexAnimationManager::RegisterPlayer(AHexPawn* Pawn)
{
    // Implementation
}

void AHexAnimationManager::UnregisterPlayer(AHexPawn* Pawn)
{
    // Implementation
}

void AHexAnimationManager::BatchUpdateAnimations()
{
    // Implementation
}


================================================
FILE: Private/HexEnemyPawn.cpp
================================================
#include "HexEnemyPawn.h"
#include "EnemyDefinition.h"
#include "CombatComponent.h"
#include "Engine/Texture2D.h"

void AHexEnemyPawn::BeginPlay()
{
    Super::BeginPlay();
    if (EnemyData.IsNull() || !Combat) return;

    if (UEnemyDefinition* Def = EnemyData.LoadSynchronous())
    {
        Combat->SetStats(Def->BaseStats);

        // Apply loadout if provided, else fallback
        if (Def->Loadout.Num() > 0)
        {
            Combat->SetLoadout(Def->Loadout);
        }
        else
        {
            TArray<FBattleActionSlot> Fallback; Fallback.SetNum(5);
            for (auto& S : Fallback) { S.Action = EBattleAction::Attack; S.SlotCost = 1; }
            Combat->SetLoadout(Fallback);
        }

        // optional: if AHexPawn has a Portrait property, set it
        // Portrait = Def->Portrait;
    }
}

AHexEnemyPawn::AHexEnemyPawn()
{
    AutoPossessPlayer = EAutoReceiveInput::Disabled;
    AutoPossessAI     = EAutoPossessAI::Disabled; // or AIController if you need AI later
    // no camera components here
}


================================================
FILE: Private/HexGridManager.cpp
================================================
// HexGridManager.cpp

#include "HexGridManager.h"
#include "Engine/World.h"
#include "EngineUtils.h"
#include "DrawDebugHelpers.h"
#include "HexTile.h"
#include "Kismet/GameplayStatics.h"

// Deltas voisins en doubled-q: W, NW, NE, E, SE, SW
static const FHexAxialCoordinates GDQ6[6] = {
    {-2, 0}, {-2, +1}, {0, +1}, {+2, 0}, {+2, -1}, {0, -1}};

static void DumpNeighborsOf(const UHexGridManager *Grid, const FHexAxialCoordinates &C, const TCHAR *Label)
{
    UE_LOG(LogTemp, Warning, TEXT("[Dbg] %s center=(%d,%d)"), Label, C.Q, C.R);

    // Candidats attendus
    for (int i = 0; i < 6; ++i)
    {
        const FHexAxialCoordinates N{C.Q + GDQ6[i].Q, C.R + GDQ6[i].R};
        const bool bPresent = (Grid && Grid->GetHexTileAt(N) != nullptr);
        UE_LOG(LogTemp, Warning, TEXT("[Dbg]  cand %d -> (%d,%d) present=%d"), i, N.Q, N.R, bPresent ? 1 : 0);
    }

    // Ce que renvoie rÃ©ellement GetNeighbors
    if (Grid)
    {
        TArray<FHexAxialCoordinates> Out = Grid->GetNeighbors(C);
        FString S = FString::JoinBy(Out, TEXT(" "),
                                    [](const FHexAxialCoordinates &X)
                                    { return FString::Printf(TEXT("(%d,%d)"), X.Q, X.R); });
        UE_LOG(LogTemp, Warning, TEXT("[Dbg]  GetNeighbors -> %s"), *S);
    }
}

UHexGridManager::UHexGridManager()
{
    PrimaryComponentTick.bCanEverTick = false;
}

void UHexGridManager::InitializeGrid(int32 Radius, TSubclassOf<AHexTile> TileClass)
{
    GridRadius = Radius;
    HexTileClass = TileClass;
    RebuildGrid();
}

void UHexGridManager::RebuildGrid()
{
    // 1) DÃ©truire l'existant
    for (auto &Kvp : TilesMap)
    {
        if (AHexTile *T = Kvp.Value.Get())
        {
            if (IsValid(T) && !T->IsActorBeingDestroyed())
                T->Destroy();
        }
    }
    TilesMap.Empty();

    // 2) VÃ©rifs
    UWorld *World = GetWorld();
    if (!World || !*HexTileClass)
    {
        UE_LOG(LogTemp, Error, TEXT("RebuildGrid: World or HexTileClass invalid"));
        return;
    }

    // 3) Origine par dÃ©faut
    if (GridOrigin.IsNearlyZero() && GetOwner())
        GridOrigin = GetOwner()->GetActorLocation();

    UE_LOG(LogTemp, Warning, TEXT("Rebuilding hex grid (Radius=%d, TileSize=%.1f)"), GridRadius, TileSize);

    // 4) Boucle de gÃ©nÃ©ration telle que tu lâ€™utilises dÃ©jÃ  (indices affichage Col/Row = Q/R)
    for (int32 q = -GridRadius; q <= GridRadius; ++q)
    {
        const int32 rMin = FMath::Max(-GridRadius, -q - GridRadius);
        const int32 rMax = FMath::Min(GridRadius, -q + GridRadius);

        for (int32 r = rMin; r <= rMax; ++r)
        {
            FVector SpawnLocation;
            if (!TryComputeTileSpawnPosition(q, r, SpawnLocation))
                continue;

            FActorSpawnParameters P;
            P.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;

            AHexTile *Tile = World->SpawnActor<AHexTile>(HexTileClass, SpawnLocation, FRotator::ZeroRotator, P);
            if (!Tile)
                continue;

            const FHexAxialCoordinates Axial = MapSpawnIndexToAxial(q, r); // <- mapping corrigÃ©
            Tile->SetAxialCoordinates(Axial);
            if (bRandomizeEnemyOnBuild && Tile && Tile->GetTileType() == EHexTileType::Normal)
{
    const float roll = FMath::FRand();     // was: const float r = EnemyRng.FRand();
    if (roll < EnemyChance)
        Tile->SetTileType(EHexTileType::Enemy);
}
#if WITH_EDITOR
            Tile->SetActorLabel(FString::Printf(TEXT("Hex (%d,%d)"), Axial.Q, Axial.R));
#endif
            TilesMap.Add(Axial, TWeakObjectPtr<AHexTile>(Tile));
        }
    }
    DumpNeighborsOf(this, FHexAxialCoordinates{0, 0}, TEXT("AfterRebuild"));
    DumpNeighborsOf(this, FHexAxialCoordinates{-8, -1}, TEXT("AfterRebuild"));
    ApplySpecialTiles();

    // Optionnel
    BuildWorldNeighbors();
}

void UHexGridManager::ApplySpecialTiles()
{
    for (const FHexAxialCoordinates &C : ShopTiles)
    {
        if (AHexTile *T = GetHexTileAt(C))
        {
            T->SetTileType(EHexTileType::Shop);
#if WITH_EDITOR
            T->SetActorLabel(FString::Printf(TEXT("Shop (%d,%d)"), C.Q, C.R));
#endif
        }
        else
        {
            UE_LOG(LogTemp, Warning, TEXT("[Hex] Shop coord inconnue (%d,%d)"), C.Q, C.R);
        }
    }
    for (const FHexAxialCoordinates& C : EnemyTiles)
    if (AHexTile* T = GetHexTileAt(C))
        T->SetTileType(EHexTileType::Enemy);
}

FVector UHexGridManager::ComputeTileSpawnPosition(int32 Q, int32 R) const
{
    // Placement monde EXISTANT conservÃ©
    const float HexWidth = TileSize * 2.0f;
    const float HexHeight = TileSize * YSpacingFactor;
    const float XOffset = Q * HexWidth * XSpacingFactor;
    const float YOffset = R * HexHeight;

    const bool bIsOdd = bOffsetOnQ ? (Q & 1) : (R & 1);
    const float RowShift = bIsOdd ? (HexHeight * RowOffsetFactor) : 0.f;

    float FinalX = GridOrigin.X + XOffset + GlobalXYNudge.X;
    float FinalY = GridOrigin.Y + YOffset + RowShift + GlobalXYNudge.Y;
    float FinalZ = GridOrigin.Z;

    const FVector Base(FinalX, FinalY, FinalZ);

    // Trace vertical pour le Z
    const FVector Start = Base + FVector(0, 0, TraceHeight);
    const FVector End = Base - FVector(0, 0, TraceDepth);

    FHitResult Hit;
    FCollisionQueryParams Params(SCENE_QUERY_STAT(HexGroundTrace), bTraceComplex);
    if (const AActor *Owner = GetOwner())
        Params.AddIgnoredActor(Owner);

    bool bHit = GetWorld()->LineTraceSingleByChannel(Hit, Start, End, ECC_Visibility, Params);
    if (!bHit)
    {
        FCollisionObjectQueryParams Obj;
        Obj.AddObjectTypesToQuery(ECC_WorldStatic);
        Obj.AddObjectTypesToQuery(ECC_WorldDynamic);
        bHit = GetWorld()->LineTraceSingleByObjectType(Hit, Start, End, Obj, Params);
    }
    /**
    #if WITH_EDITOR
        if (bDebugTrace)
        {
            DrawDebugLine(GetWorld(), Start, End, bHit ? FColor::Green : FColor::Red, false, 5.f, 0, 2.f);
            if (bHit) DrawDebugPoint(GetWorld(), Hit.Location, 12.f, FColor::Yellow, false, 5.f);
        }
    #endif
    */
    if (bHit)
        FinalZ = Hit.Location.Z + TileZOffset;
    return FVector(FinalX, FinalY, FinalZ);
}

bool UHexGridManager::TryComputeTileSpawnPosition(int32 Q, int32 R, FVector &OutLocation) const
{
    // Placement monde EXISTANT conservÃ©
    const float HexWidth = TileSize * 2.0f;
    const float HexHeight = TileSize * YSpacingFactor;
    const float XOffset = Q * HexWidth * XSpacingFactor;
    const float YOffset = R * HexHeight;

    const bool bIsOdd = bOffsetOnQ ? (Q & 1) : (R & 1);
    const float RowShift = bIsOdd ? (HexHeight * RowOffsetFactor) : 0.f;

    float FinalX = GridOrigin.X + XOffset + GlobalXYNudge.X;
    float FinalY = GridOrigin.Y + YOffset + RowShift + GlobalXYNudge.Y;
    float FinalZ = GridOrigin.Z;

    const FVector Base(FinalX, FinalY, FinalZ);
    const FVector Start = Base + FVector(0, 0, TraceHeight);
    const FVector End = Base - FVector(0, 0, TraceDepth);

    FHitResult Hit;
    FCollisionQueryParams Params(SCENE_QUERY_STAT(HexGroundTrace), bTraceComplex);
    if (const AActor *Owner = GetOwner())
        Params.AddIgnoredActor(Owner);

    bool bHit = GetWorld()->LineTraceSingleByChannel(Hit, Start, End, ECC_Visibility, Params);
    if (!bHit)
    {
        FCollisionObjectQueryParams Obj;
        Obj.AddObjectTypesToQuery(ECC_WorldStatic);
        Obj.AddObjectTypesToQuery(ECC_WorldDynamic);
        bHit = GetWorld()->LineTraceSingleByObjectType(Hit, Start, End, Obj, Params);
    }
    /*
    #if WITH_EDITOR
        if (bDebugTrace)
        {
            DrawDebugLine(GetWorld(), Start, End, bHit ? FColor::Green : FColor::Red, false, 5.f, 0, 2.f);
            if (bHit)
                DrawDebugPoint(GetWorld(), Hit.Location, 12.f, FColor::Yellow, false, 5.f);
        }
    #endif
     */
    if (!bHit)
    {
        UE_LOG(LogTemp, Verbose, TEXT("[HexGrid] (%d,%d): no ground hit"), Q, R);
        return false;
    }

    const AActor *HitA = Hit.GetActor();
    if (bSkipTilesOverFloor)
    {
        if (!HitA)
        {
            UE_LOG(LogTemp, Warning, TEXT("[HexGrid] (%d,%d): hit no actor -> skip"), Q, R);
            return false;
        }
        if (HitA->ActorHasTag(FloorTag))
        {
            UE_LOG(LogTemp, Warning, TEXT("[HexGrid] (%d,%d): Floor tag on %s -> skip"), Q, R, *HitA->GetName());
            return false;
        }
    }

    FinalZ = Hit.Location.Z + TileZOffset;
    OutLocation = FVector(FinalX, FinalY, FinalZ);
    return true;
}

// -------- Mapping Offset -> Axial standard -> Doubled-Q --------

static FORCEINLINE int32 FloorDiv2_Int(int32 x)
{
    // floor(x/2) pour entiers signÃ©s
    return (x >= 0) ? (x >> 1) : -((-x + 1) >> 1);
}

FHexAxialCoordinates UHexGridManager::MapSpawnIndexToAxial(int32 Col, int32 Row) const
{
    // Col/Row = indices utilisÃ©s par TON placement existant
    // Convertit Offset â†’ axial standard, puis axial â†’ doubled-q

    int32 q_ax = 0;
    int32 r_ax = 0;

    if (bOffsetOnQ)
    {
        // Colonnes dÃ©calÃ©es (pointy-top). Odd-Q
        // axial: q = col ; r = row - floor(col/2)
        q_ax = Col;
        r_ax = Row - FloorDiv2_Int(Col);
    }
    else
    {
        // Lignes dÃ©calÃ©es (flat-top). Odd-R
        // axial: q = col - floor(row/2) ; r = row
        q_ax = Col - FloorDiv2_Int(Row);
        r_ax = Row;
    }

    // Doubled-Q: q' = 2*q ; r' = r
    return FHexAxialCoordinates{q_ax * 2, r_ax};
}

// ---------------------------------------------------------------

AHexTile *UHexGridManager::GetHexTileAt(const FHexAxialCoordinates &Coords) const
{
    if (const TWeakObjectPtr<AHexTile> *Found = TilesMap.Find(Coords))
        return Found->IsValid() ? Found->Get() : nullptr;
    return nullptr;
}

TArray<FHexAxialCoordinates> UHexGridManager::GetNeighbors(const FHexAxialCoordinates &C) const
{
    TArray<FHexAxialCoordinates> Out;
    Out.Reserve(6);
    for (int i = 0; i < 6; ++i)
    {
        const FHexAxialCoordinates N{C.Q + GDQ6[i].Q, C.R + GDQ6[i].R};
        if (GetHexTileAt(N))
            Out.Add(N);

        // Log ciblÃ© sur la tuile problÃ©matique
        if (C.Q == -8 && C.R == -1)
        {
            const bool bHas = GetHexTileAt(N) != nullptr;
            UE_LOG(LogTemp, Warning, TEXT("[Dbg] GetNeighbors@(-8,-1) try (%d,%d) -> %d"), N.Q, N.R, bHas ? 1 : 0);
        }
    }
    return Out;
}

int32 UHexGridManager::AxialDistance(const FHexAxialCoordinates &A, const FHexAxialCoordinates &B) const
{
    const int32 dq = FMath::Abs(A.Q - B.Q);
    const int32 dr = FMath::Abs(A.R - B.R);
    return FMath::Max(dr, (dq + dr) / 2);
}

void UHexGridManager::BuildWorldNeighbors()
{
    WorldNeighbors.Empty();

    UWorld *World = GetWorld();
    if (!World)
        return;

    TMap<FHexAxialCoordinates, FVector> Pos;
    for (TActorIterator<AHexTile> It(World); It; ++It)
        if (IsValid(*It))
            Pos.Add(It->GetAxialCoordinates(), It->GetActorLocation());

    for (const auto &ItA : Pos)
    {
        const FHexAxialCoordinates AKey = ItA.Key;
        const FVector APos = ItA.Value;

        struct FNeighborDist
        {
            FHexAxialCoordinates Key;
            float D2;
        };
        TArray<FNeighborDist> D;
        D.Reserve(16);

        for (const auto &ItB : Pos)
        {
            if (ItB.Key == AKey)
                continue;
            const float d2 = (ItB.Value - APos).SizeSquared2D(); // float sÃ»r
            D.Add({ItB.Key, d2});
        }

        D.Sort([](const FNeighborDist &L, const FNeighborDist &R)
               { return L.D2 < R.D2; });

        TArray<FHexAxialCoordinates> Neigh;
        const int32 Count = FMath::Min(6, D.Num());
        Neigh.Reserve(Count);
        for (int32 i = 0; i < Count; ++i)
            Neigh.Add(D[i].Key);

        WorldNeighbors.Add(AKey, MoveTemp(Neigh));
    }

#if !UE_BUILD_SHIPPING
    UE_LOG(LogTemp, Warning, TEXT("[Hex] WorldNeighbors built for %d tiles"), WorldNeighbors.Num());
#endif
}

void UHexGridManager::GetNeighborsByWorld(const FHexAxialCoordinates &From, TArray<FHexAxialCoordinates> &Out) const
{
    if (const TArray<FHexAxialCoordinates> *Found = WorldNeighbors.Find(From))
        Out = *Found;
    else
        Out.Reset();
}

void UHexGridManager::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
    // Ã‰vite dÃ©rÃ©fÃ©rencer des acteurs pendant teardown
    TilesMap.Empty();
    WorldNeighbors.Empty();
    Super::EndPlay(EndPlayReason);
}

void UHexGridManager::BeginDestroy()
{
    // SÃ©curitÃ© hot-reload / editor
    TilesMap.Empty();
    WorldNeighbors.Empty();
    Super::BeginDestroy();
}



================================================
FILE: Private/HexPathFinder.cpp
================================================
#include "HexPathFinder.h"
#include "HexGridManager.h"
#include "Algo/Reverse.h"

UHexPathFinder::UHexPathFinder()
{
	PrimaryComponentTick.bCanEverTick = false;
}

void UHexPathFinder::GetValidNeighbors(const FHexAxialCoordinates& From,
                                       TArray<FHexAxialCoordinates>& Out) const
{
	Out.Reset();
	if (!GridRef) return;
	Out = GridRef->GetNeighbors(From);
}

int32 UHexPathFinder::Heuristic(const FHexAxialCoordinates& A, const FHexAxialCoordinates& B) const
{
	// Heuristique admissible fournie par la grille (doubled-q / axial)
	return GridRef ? GridRef->AxialDistance(A, B) : 0;
}

void UHexPathFinder::ReconstructPath(const TMap<FHexAxialCoordinates,FHexAxialCoordinates>& Parent,
                                     const FHexAxialCoordinates& Start,
                                     const FHexAxialCoordinates& Goal,
                                     TArray<FHexAxialCoordinates>& OutPath)
{
	OutPath.Reset();
	FHexAxialCoordinates Cur = Goal;
	OutPath.Add(Cur);
	while (!(Cur == Start))
	{
		if (const FHexAxialCoordinates* Prev = Parent.Find(Cur))
		{
			Cur = *Prev;
			OutPath.Add(Cur);
		}
		else
		{
			OutPath.Reset(); // cassÃ©
			return;
		}
	}
	Algo::Reverse(OutPath);
}

TArray<FHexAxialCoordinates> UHexPathFinder::FindPath(const FHexAxialCoordinates& Start,
                                                      const FHexAxialCoordinates& Goal)
{
    TArray<FHexAxialCoordinates> Empty;
    if (!GridRef) return Empty;

    if (Start == Goal)
    {
        TArray<FHexAxialCoordinates> P; P.Add(Start);
        return P;
    }

    TSet<FHexAxialCoordinates> Open, Closed;
    TMap<FHexAxialCoordinates, FHexAxialCoordinates> Parent;
    TMap<FHexAxialCoordinates, int32> GScore, FScore;

    Open.Add(Start);
    Parent.Add(Start, Start);
    GScore.Add(Start, 0);
    FScore.Add(Start, Heuristic(Start, Goal));

    while (Open.Num() > 0)
    {
        // Choisir le noeud avec F-score min
        FHexAxialCoordinates Current = *Open.CreateConstIterator();
        int32 BestF = FScore.FindRef(Current);
        for (const FHexAxialCoordinates& N : Open)
        {
            const int32 FN = FScore.FindRef(N);
            if (FN < BestF)
            {
                BestF = FN;
                Current = N;
            }
        }

        if (Current == Goal)
        {
            TArray<FHexAxialCoordinates> OutPath;
            ReconstructPath(Parent, Start, Goal, OutPath);

            // Limite de dÃ©placement par tour: 6 pas (donc 7 nÅ“uds Start+6)
            if (OutPath.Num() > 0)
            {
                const int32 MaxStepsPerTurn = 6; // arbitraire pour lâ€™instant
                const int32 MaxLen = FMath::Max(1, MaxStepsPerTurn + 1); // +1 pour inclure Start
                if (OutPath.Num() > MaxLen)
                {
                    OutPath.SetNum(MaxLen, EAllowShrinking::No);
                }
            }
            return OutPath;
        }

        Open.Remove(Current);
        Closed.Add(Current);

        // Voisins valides
        TArray<FHexAxialCoordinates> Neighbors;
        GetValidNeighbors(Current, Neighbors);

        const int32 GCur = GScore.FindRef(Current);
        for (const FHexAxialCoordinates& N : Neighbors)
        {
            if (Closed.Contains(N)) continue;

            const int32 TentativeG = GCur + 1;
            bool bBetter = false;

            if (!Open.Contains(N))
            {
                Open.Add(N);
                bBetter = true;
            }
            else if (TentativeG < GScore.FindRef(N))
            {
                bBetter = true;
            }

            if (bBetter)
            {
                Parent.Add(N, Current);
                GScore.Add(N, TentativeG);
                FScore.Add(N, TentativeG + Heuristic(N, Goal));
            }
        }
    }

    return Empty;
}


================================================
FILE: Private/HexPawn.cpp
================================================
// HexPawn.cpp
#include "HexPawn.h"

#include "Camera/CameraComponent.h"
#include "Components/SceneComponent.h"
#include "GameFramework/PlayerController.h"
#include "GameFramework/SpringArmComponent.h"
#include "Engine/World.h"
#include "Kismet/GameplayStatics.h"
#include "Net/UnrealNetwork.h"

#include "HexAnimationTypes.h"
#include "HexGridManager.h"
#include "HexSpriteComponent.h"
#include "HexTile.h"
#include "CombatComponent.h"
#include "DemoGameMode.h"

AHexPawn::AHexPawn()
{
    
    PrimaryActorTick.bCanEverTick = true;
    bReplicates = true;
    SetNetUpdateFrequency(60.f);
    SetMinNetUpdateFrequency(30.f);

    if (!RootComponent)
    {
        RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));
    }

    // Constructor
    CameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraBoom"));
    CameraBoom->SetupAttachment(RootComponent);
    CameraBoom->TargetArmLength = CameraHeight;
    CameraBoom->bDoCollisionTest = false;

    // Don't take controller or parent rotation
    CameraBoom->bUsePawnControlRotation = false;
    CameraBoom->bInheritPitch = false;
    CameraBoom->bInheritYaw = false;
    CameraBoom->bInheritRoll = false;
    CameraBoom->SetUsingAbsoluteRotation(true);
    CameraBoom->SetRelativeRotation(FRotator(0.f, 0.f, 0.f));

    TopDownCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("TopDownCamera"));
    TopDownCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);
    TopDownCamera->bUsePawnControlRotation = false;
    TopDownCamera->SetProjectionMode(ECameraProjectionMode::Perspective);
    TopDownCamera->SetFieldOfView(60.f);
    TopDownCamera->SetAspectRatio(16.f / 9.f);
    TopDownCamera->SetWorldLocation(FVector(0.f, 0.f, -150.f));

    // (optional, belt & suspenders)
    bUseControllerRotationYaw = false;
    bUseControllerRotationPitch = false;
    bUseControllerRotationRoll = false;

    SpriteComp = CreateDefaultSubobject<UHexSpriteComponent>(TEXT("SpriteComp"));
    SpriteComp->SetupAttachment(RootComponent);
    SpriteComp->bEditableWhenInherited = true;

    Combat = CreateDefaultSubobject<UCombatComponent>(TEXT("Combat"));
}

void AHexPawn::BeginPlay()
{
    Super::BeginPlay();

    // Rebind to instance sprite if the CDO component leaked through
    if (!SpriteComp || SpriteComp->HasAnyFlags(RF_ClassDefaultObject) || SpriteComp->GetOwner() != this)
    {
        if (UHexSpriteComponent *Found = FindComponentByClass<UHexSpriteComponent>())
        {
            SpriteComp = Found;
        }
        else
        {
            UE_LOG(LogTemp, Error, TEXT("[Sprite] Missing UHexSpriteComponent on instance"));
        }
    }

    if (SpriteComp)
    {
        SpriteBaseScale = SpriteComp->GetRelativeScale3D().GetAbs();
        SpriteComp->SetPlayRate(1.f);
        SpriteComp->SetAnimationState(EHexAnimState::Idle);
    }

    if (CameraBoom)
    {
        CameraBoom->SetUsingAbsoluteRotation(true);
        CameraBoom->SetRelativeRotation(FRotator(-50.f, 0.f, 0.f));
    }
    if (TopDownCamera)
    {
        TopDownCamera->bUsePawnControlRotation = false;
    }

    if (APlayerController *PC = UGameplayStatics::GetPlayerController(this, 0))
    {
        PC->bAutoManageActiveCameraTarget = false;
        PC->SetViewTargetWithBlend(this, 0.f);
        PC->SetControlRotation(FRotator::ZeroRotator); // ensure no leftover editor rot
    }
}

void AHexPawn::UpdateSpriteMirrorToward(const FVector &From, const FVector &To)
{
    if (!SpriteComp)
        return;

    const FVector2D MoveDir2D = FVector2D(To - From).GetSafeNormal();
    if (MoveDir2D.IsNearlyZero())
        return;

    const FVector2D CamRight2D = FVector2D(TopDownCamera ? TopDownCamera->GetRightVector() : FVector::RightVector);
    const bool bGoingRight = FVector2D::DotProduct(MoveDir2D, CamRight2D) >= 0.f;

    FVector S = SpriteBaseScale;
    S.X = bGoingRight ? FMath::Abs(S.X) : -FMath::Abs(S.X); // horizontal flip
    SpriteComp->SetRelativeScale3D(S);
}

void AHexPawn::StartPathFollowing(const TArray<FHexAxialCoordinates> &InPath, UHexGridManager *InGridManager)
{
    GridRef = InGridManager;
    CurrentPath = InPath;

    int32 StartIndex = 0;
    if (CurrentTile && CurrentPath.Num() > 0 && CurrentPath[0] == CurrentTile->GetAxialCoordinates())
    {
        StartIndex = 1;
    }

    if (!GridRef || !CurrentPath.IsValidIndex(StartIndex))
    {
        bIsMoving = false;
        if (HasAuthority() && SpriteComp)
            SpriteComp->SetAnimationState(EHexAnimState::Idle);
        return;
    }

    CurrentStepIndex = StartIndex;

    AHexTile *NextTile = GridRef->GetHexTileAt(CurrentPath[CurrentStepIndex]);
    if (!NextTile)
    {
        bIsMoving = false;
        if (HasAuthority() && SpriteComp)
            SpriteComp->SetAnimationState(EHexAnimState::Idle);
        return;
    }

    StartLocation = GetActorLocation();
    TargetLocation = NextTile->GetActorLocation();
    StepElapsed = 0.f;
    bIsMoving = true;

    UpdateSpriteMirrorToward(StartLocation, TargetLocation);
    if (HasAuthority() && SpriteComp)
        SpriteComp->SetAnimationState(EHexAnimState::Walking);
}

void AHexPawn::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);

    if (!bIsMoving)
    {
        if (HasAuthority() && SpriteComp)
            SpriteComp->SetAnimationState(EHexAnimState::Idle);

        if (ADemoGameMode* GM = GetWorld()->GetAuthGameMode<ADemoGameMode>())
            GM->UpdateReachableVisibility(3);
        return;
    }

    StepElapsed += DeltaTime;
    float Alpha = (StepDuration > SMALL_NUMBER) ? FMath::Clamp(StepElapsed / StepDuration, 0.f, 1.f) : 1.f;
    if (bEaseInOut) Alpha = Alpha * Alpha * (3.f - 2.f * Alpha); // smoothstep

    const FVector NewLoc = FMath::Lerp(StartLocation, TargetLocation, Alpha);
    SetActorLocation(NewLoc);

    if (bFaceDirection)
    {
        const FVector Dir2D(TargetLocation.X - NewLoc.X, TargetLocation.Y - NewLoc.Y, 0.f);
        if (!Dir2D.IsNearlyZero())
        {
            const FRotator Cur = GetActorRotation();
            const FRotator Want = Dir2D.Rotation();
            const float DeltaYaw = FMath::FindDeltaAngleDegrees(Cur.Yaw, Want.Yaw);
            const float MaxStep = TurnRateDegPerSec * DeltaTime;
            SetActorRotation(FRotator(0.f, Cur.Yaw + FMath::Clamp(DeltaYaw, -MaxStep, MaxStep), 0.f));
        }
    }

    if (Alpha >= 1.f - KINDA_SMALL_NUMBER)
    {
        // Snap to target of the current step
        SetActorLocation(TargetLocation);

        // Update current tile based on where we just landed
        if (GridRef && CurrentPath.IsValidIndex(CurrentStepIndex))
        {
            if (AHexTile* Landed = GridRef->GetHexTileAt(CurrentPath[CurrentStepIndex]))
                CurrentTile = Landed;
        }

        // Advance to next step
        ++CurrentStepIndex;

        // Finished path?
        if (!GridRef || !CurrentPath.IsValidIndex(CurrentStepIndex))
        {
            bIsMoving = false;
            if (HasAuthority() && SpriteComp)
                SpriteComp->SetAnimationState(EHexAnimState::Idle);

            if (ADemoGameMode* GM = GetWorld()->GetAuthGameMode<ADemoGameMode>())
            {
                GM->OnPawnArrived(this);          // <-- trigger tile effects (enemy, etc.)
                GM->UpdateReachableVisibility(3);
            }
            return;
        }

        // Prepare next step
        AHexTile* NextTile = GridRef->GetHexTileAt(CurrentPath[CurrentStepIndex]);
        if (!NextTile)
        {
            bIsMoving = false;
            if (HasAuthority() && SpriteComp)
                SpriteComp->SetAnimationState(EHexAnimState::Idle);

            if (ADemoGameMode* GM = GetWorld()->GetAuthGameMode<ADemoGameMode>())
            {
                GM->OnPawnArrived(this);
                GM->UpdateReachableVisibility(3);
            }
            return;
        }

        // Optional sanity: require adjacency
        if (CurrentTile && GridRef)
        {
            const FHexAxialCoordinates Cur  = CurrentTile->GetAxialCoordinates();
            const FHexAxialCoordinates Next = CurrentPath[CurrentStepIndex];
            const bool bAdjacent = GridRef->GetNeighbors(Cur).Contains(Next);
            if (!bAdjacent || !GridRef->GetHexTileAt(Next))
            {
                UE_LOG(LogTemp, Warning, TEXT("[Move] Invalid step: (%d,%d)->(%d,%d). Stop."),
                       Cur.Q, Cur.R, Next.Q, Next.R);

                bIsMoving = false;
                if (HasAuthority() && SpriteComp)
                    SpriteComp->SetAnimationState(EHexAnimState::Idle);

                if (ADemoGameMode* GM = GetWorld()->GetAuthGameMode<ADemoGameMode>())
                {
                    GM->OnPawnArrived(this);
                    GM->UpdateReachableVisibility(3);
                }
                return;
            }
        }

        StartLocation = GetActorLocation();
        TargetLocation = NextTile->GetActorLocation();
        StepElapsed = 0.f;
        bIsMoving = true;

        UpdateSpriteMirrorToward(StartLocation, TargetLocation);
    }
}

void AHexPawn::SetCurrentTile(AHexTile *NewTile)
{
    CurrentTile = NewTile;
}

void AHexPawn::InitializePawnStartTile(const FHexAxialCoordinates &StartCoords)
{
    UWorld *World = GetWorld();
    if (!World)
        return;

    ADemoGameMode *GM = World->GetAuthGameMode<ADemoGameMode>();
    if (!GM)
        return;

    UHexGridManager *Grid = GM->GetHexGridManager();
    if (!Grid)
        return;

    AHexTile *Tile = Grid->GetHexTileAt(StartCoords);
    if (!Tile)
    {
        UE_LOG(LogTemp, Error, TEXT("InitializePawnStartTile: No tile at (%d,%d)"), StartCoords.Q, StartCoords.R);
        return;
    }

    CurrentTile = Tile;
    SetActorLocation(Tile->GetActorLocation());
    UE_LOG(LogTemp, Warning, TEXT("Pawn initialized on tile (%d,%d)"), StartCoords.Q, StartCoords.R);
}

void AHexPawn::GetLifetimeReplicatedProps(TArray<FLifetimeProperty> &OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);
    DOREPLIFETIME(AHexPawn, ReplicatedPath);
}

void AHexPawn::OnRep_CurrentPath()
{
    if (!GridRef)
    {
        if (ADemoGameMode *GM = GetWorld() ? GetWorld()->GetAuthGameMode<ADemoGameMode>() : nullptr)
        {
            GridRef = GM ? GM->GetHexGridManager() : nullptr;
        }
    }
    if (GridRef && ReplicatedPath.Num() > 0)
    {
        StartPathFollowing(ReplicatedPath, GridRef);
    }
}

void AHexPawn::ServerRequestMove_Implementation(const TArray<FHexAxialCoordinates> &NewPath)
{
    ReplicatedPath = NewPath;
    StartPathFollowing(NewPath, GridRef);
}

void AHexPawn::PossessedBy(AController *NewController)
{
    Super::PossessedBy(NewController);
    if (APlayerController *PC = Cast<APlayerController>(NewController))
    {
        PC->bAutoManageActiveCameraTarget = false;
        PC->SetViewTarget(this);
    }
}

void AHexPawn::OnRep_Controller()
{
    Super::OnRep_Controller();
    if (APlayerController *PC = Cast<APlayerController>(GetController()))
    {
        PC->bAutoManageActiveCameraTarget = false;
        PC->ClientSetViewTarget(this);
    }
}



================================================
FILE: Private/HexSpriteComponent.cpp
================================================
#include "HexSpriteComponent.h"
#include "Net/UnrealNetwork.h"

UHexSpriteComponent::UHexSpriteComponent()
{
    SetIsReplicatedByDefault(true);
    SetLooping(true);
}

void UHexSpriteComponent::SetAnimationState(EHexAnimState NewState)
{
    if (CurrentAnimState == NewState)
        return;
    CurrentAnimState = NewState;
    UE_LOG(LogTemp, Warning, TEXT("[SpriteComp %s] SetAnimationState -> %s | Owner=%s IsCDO=%d"),
           *GetName(),
           *UEnum::GetValueAsString(NewState),
           *GetNameSafe(GetOwner()),
           HasAnyFlags(RF_ClassDefaultObject) ? 1 : 0);
    ApplyAnim();
}

void UHexSpriteComponent::OnRep_AnimState()
{
    UE_LOG(LogTemp, Warning, TEXT("[SpriteComp %s] OnRep_AnimState -> %s"),
           *GetOwner()->GetName(),
           *UEnum::GetValueAsString(CurrentAnimState));
    ApplyAnim();
}

void UHexSpriteComponent::ApplyAnim()
{
    UPaperFlipbook *Wanted = nullptr;
    switch (CurrentAnimState)
    {
    case EHexAnimState::Walking:
        Wanted = WalkAnim;
        break;
    default:
        Wanted = IdleAnim;
        break;
    }

    if (Wanted && GetFlipbook() != Wanted)
    {
        SetFlipbook(Wanted);
        PlayFromStart();
    }
    else if (Wanted && !IsPlaying())
    {
        Play();
    }
}

void UHexSpriteComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty> &OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);
    DOREPLIFETIME(UHexSpriteComponent, CurrentAnimState);
}



================================================
FILE: Private/HexTile.cpp
================================================
// HexTile.cpp
#include "HexTile.h"
#include "Components/SceneComponent.h"
#include "Components/StaticMeshComponent.h"
#include "Kismet/GameplayStatics.h"
#include "DemoGameMode.h"
#include "Materials/MaterialInstanceDynamic.h"

namespace
{
    const FName PARAM_BaseColor     = TEXT("BaseColor");
    const FName PARAM_Color         = TEXT("Color");
    const FName PARAM_Albedo        = TEXT("Albedo");
    const FName PARAM_Opacity       = TEXT("Opacity");
    const FName PARAM_EmissiveColor = TEXT("EmissiveColor");
    const FName PARAM_EmissiveStr   = TEXT("EmissiveStrength");
    const FName PARAM_IsHighlighted = TEXT("IsHighlighted");
}

AHexTile::AHexTile()
{
    SceneRoot = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));
    RootComponent = SceneRoot;

    PrimaryActorTick.bCanEverTick = true;
    SetActorTickEnabled(false);
}

void AHexTile::PostInitializeComponents()
{
    Super::PostInitializeComponents();

    OnClicked.AddDynamic(this, &AHexTile::HandleOnClicked);
    OnBeginCursorOver.AddDynamic(this, &AHexTile::HandleOnBeginCursorOver);
    OnEndCursorOver.AddDynamic(this, &AHexTile::HandleOnEndCursorOver);
}

void AHexTile::BeginPlay()
{
    Super::BeginPlay();

    BaseZ = GetActorLocation().Z;
    TargetZ = BaseZ;
    bElevInterpActive = false;

    if (UStaticMeshComponent* Mesh = GetVisualMesh())
    {
        if (Mesh->Mobility != EComponentMobility::Movable)
            Mesh->SetMobility(EComponentMobility::Movable);

        if (!DynamicMaterial)
            DynamicMaterial = Mesh->CreateAndSetMaterialInstanceDynamic(0);

        if (DynamicMaterial)
        {
            DynamicMaterial->SetScalarParameterValue(PARAM_IsHighlighted, bIsHighlighted ? 1.0f : 0.0f);
            UpdateMaterialColor();

            if (TileType == EHexTileType::Shop)
            {
                DynamicMaterial->SetVectorParameterValue(PARAM_BaseColor,     TypeTint_Shop);
                DynamicMaterial->SetVectorParameterValue(PARAM_EmissiveColor, TypeTint_Shop);
                DynamicMaterial->SetScalarParameterValue(PARAM_EmissiveStr,   0.5f);
            }
        }
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("HexTile: no visual mesh found on %s"), *GetName());
    }
}

void AHexTile::OnConstruction(const FTransform& Xform)
{
    Super::OnConstruction(Xform);
    ApplyMaterialForType();
}

void AHexTile::Tick(float DeltaSeconds)
{
    Super::Tick(DeltaSeconds);

    if (!bElevInterpActive) return;

    FVector Loc = GetActorLocation();
    const float NewZ = FMath::FInterpTo(Loc.Z, TargetZ, DeltaSeconds, HighlightLerpSpeed);
    Loc.Z = NewZ;
    SetActorLocation(Loc);

    if (FMath::IsNearlyEqual(NewZ, TargetZ, 0.5f))
    {
        Loc.Z = TargetZ;
        SetActorLocation(Loc);
        bElevInterpActive = false;
        SetActorTickEnabled(false);
    }
}

UStaticMeshComponent* AHexTile::GetVisualMesh()
{
    if (IsValid(CachedVisualMesh) && !CachedVisualMesh->IsBeingDestroyed())
        return CachedVisualMesh;

    if (IsValid(TileMesh))
        return CachedVisualMesh = TileMesh;

    TArray<UStaticMeshComponent*> Comps;
    GetComponents<UStaticMeshComponent>(Comps);

    if (VisualMeshTag != NAME_None)
    {
        for (auto* C : Comps)
            if (IsValid(C) && C->ComponentHasTag(VisualMeshTag))
                return CachedVisualMesh = C;
    }

    const FString Wanted = VisualMeshName.ToString();
    for (auto* C : Comps)
        if (IsValid(C) && C->GetName().Equals(Wanted, ESearchCase::CaseSensitive))
            return CachedVisualMesh = C;

    return CachedVisualMesh = (Comps.Num() ? Comps[0] : nullptr);
}

void AHexTile::HandleOnClicked(AActor*, FKey)
{
    if (TileType == EHexTileType::Shop || bIsShop || ActorHasTag(TEXT("Shop")))
    {
        if (ADemoGameMode* GM = Cast<ADemoGameMode>(UGameplayStatics::GetGameMode(this)))
            GM->OpenShopAt(this);
        return;
    }

    if (ADemoGameMode* GM = Cast<ADemoGameMode>(UGameplayStatics::GetGameMode(this)))
        GM->HandleTileClicked(this);
}

void AHexTile::HandleOnBeginCursorOver(AActor*)
{
    SetHighlighted(true);

    if (ADemoGameMode* GM = Cast<ADemoGameMode>(UGameplayStatics::GetGameMode(this)))
        GM->PreviewPathTo(this);

    if (TileType == EHexTileType::Shop || bIsShop)
        if (UStaticMeshComponent* Mesh = GetVisualMesh())
            if (!Mesh->bRenderCustomDepth)
                Mesh->SetRenderCustomDepth(true);
}

void AHexTile::HandleOnEndCursorOver(AActor*)
{
    SetHighlighted(false);

    if (ADemoGameMode* GM = Cast<ADemoGameMode>(UGameplayStatics::GetGameMode(this)))
        GM->ClearPreview();

    if (TileType == EHexTileType::Shop || bIsShop)
        if (UStaticMeshComponent* Mesh = GetVisualMesh())
            if (Mesh->bRenderCustomDepth)
                Mesh->SetRenderCustomDepth(false);
}

void AHexTile::SetHighlighted(bool bHighlight)
{
    if (bIsHighlighted == bHighlight) return;
    bIsHighlighted = bHighlight;

    UStaticMeshComponent* Mesh = GetVisualMesh();
    if (Mesh && !DynamicMaterial)
        DynamicMaterial = Mesh->CreateAndSetMaterialInstanceDynamic(0);

    if (DynamicMaterial)
    {
        DynamicMaterial->SetScalarParameterValue(PARAM_IsHighlighted, bIsHighlighted ? 1.0f : 0.0f);
        DynamicMaterial->SetScalarParameterValue(PARAM_EmissiveStr,  bIsHighlighted ? GlowStrengthOn : GlowStrengthOff);
        DynamicMaterial->SetVectorParameterValue(PARAM_EmissiveColor, GlowColor);
        UpdateMaterialColor();
    }

    if (Mesh)
    {
        if (Mesh->bRenderCustomDepth != bIsHighlighted)
            Mesh->SetRenderCustomDepth(bIsHighlighted);
        Mesh->SetCustomDepthStencilValue(1);
    }

    TargetZ = bIsHighlighted ? (BaseZ + HighlightLiftZ) : BaseZ;
    bElevInterpActive = true;
    SetActorTickEnabled(true);
}

void AHexTile::UpdateMaterialColor()
{
    if (!DynamicMaterial) return;

    const FLinearColor ColorToUse = bIsHighlighted ? HighlightColor : NormalColor;
    DynamicMaterial->SetVectorParameterValue(PARAM_BaseColor,     ColorToUse);
    DynamicMaterial->SetVectorParameterValue(PARAM_Color,         ColorToUse);
    DynamicMaterial->SetVectorParameterValue(PARAM_Albedo,        ColorToUse);
    DynamicMaterial->SetScalarParameterValue(PARAM_Opacity,       ColorToUse.A);
    DynamicMaterial->SetVectorParameterValue(PARAM_EmissiveColor, GlowColor);
    DynamicMaterial->SetScalarParameterValue(PARAM_EmissiveStr,   bIsHighlighted ? GlowStrengthOn : GlowStrengthOff);
}

void AHexTile::ApplyMaterialForType()
{
    UStaticMeshComponent* Mesh = GetVisualMesh();
    if (!Mesh) return;

    UMaterialInterface* UseMat = nullptr;
    switch (TileType)
    {
        case EHexTileType::Enemy:
            UseMat = MatEnemy.IsValid() ? MatEnemy.Get() : MatEnemy.LoadSynchronous();
            break;
        default: // Normal / Shop / Spawn / Goal
            UseMat = MatNormal.IsValid() ? MatNormal.Get() : MatNormal.LoadSynchronous();
            break;
    }

    if (UseMat) Mesh->SetMaterial(0, UseMat);
}

void AHexTile::SetTileType(EHexTileType NewType)
{
    TileType = NewType;
    ApplyMaterialForType();
}



================================================
FILE: Private/LoadoutEditorWidget.cpp
================================================
#include "LoadoutEditorWidget.h"
#include "Components/Button.h"
#include "Components/TextBlock.h"
#include "Blueprint/WidgetLayoutLibrary.h"
#include "CombatComponent.h"
#include "BattleActions.h"
#include "ActionDragOperation.h"
#include "ActionEntryWidget.h"

ULoadoutEditorWidget::ULoadoutEditorWidget(const FObjectInitializer& O):Super(O){}

void ULoadoutEditorWidget::SetCombat(UCombatComponent* InCombat)
{
    Combat = InCombat;
    SelectedSlot = 0;

    OriginalLoadout = Combat ? Combat->GetLoadout() : TArray<FBattleActionSlot>{};
    EditorLoadout   = OriginalLoadout;
    if (EditorLoadout.Num() < 5) EditorLoadout.SetNum(5);
    RefreshSlots();
}

void ULoadoutEditorWidget::NativeConstruct()
{
    Super::NativeConstruct();

    if (SlotBtn0) SlotBtn0->OnClicked.AddDynamic(this, &ULoadoutEditorWidget::OnSlot0);
    if (SlotBtn1) SlotBtn1->OnClicked.AddDynamic(this, &ULoadoutEditorWidget::OnSlot1);
    if (SlotBtn2) SlotBtn2->OnClicked.AddDynamic(this, &ULoadoutEditorWidget::OnSlot2);
    if (SlotBtn3) SlotBtn3->OnClicked.AddDynamic(this, &ULoadoutEditorWidget::OnSlot3);
    if (SlotBtn4) SlotBtn4->OnClicked.AddDynamic(this, &ULoadoutEditorWidget::OnSlot4);

    if (BtnSave)   BtnSave  ->OnClicked.AddDynamic(this, &ULoadoutEditorWidget::OnSave);
    if (BtnCancel) BtnCancel->OnClicked.AddDynamic(this, &ULoadoutEditorWidget::OnCancel);

    RefreshSlots();
}

void ULoadoutEditorWidget::RefreshSlots()
{
    auto SetOne = [](UTextBlock* T, const FBattleActionSlot& S)
    {
        if (T) T->SetText(UBattleActionLibrary::ActionToText(S.Action));
    };
    SetOne(SlotText0, EditorLoadout.IsValidIndex(0)?EditorLoadout[0]:FBattleActionSlot{});
    SetOne(SlotText1, EditorLoadout.IsValidIndex(1)?EditorLoadout[1]:FBattleActionSlot{});
    SetOne(SlotText2, EditorLoadout.IsValidIndex(2)?EditorLoadout[2]:FBattleActionSlot{});
    SetOne(SlotText3, EditorLoadout.IsValidIndex(3)?EditorLoadout[3]:FBattleActionSlot{});
    SetOne(SlotText4, EditorLoadout.IsValidIndex(4)?EditorLoadout[4]:FBattleActionSlot{});
}

int32 ULoadoutEditorWidget::HitTestSlotIndex(const FVector2D& ScreenPos) const
{
    const auto Under = [&](const UWidget* W)->bool{
        return W && W->GetCachedGeometry().IsUnderLocation(ScreenPos);
    };
    if (Under(SlotBtn0)) return 0;
    if (Under(SlotBtn1)) return 1;
    if (Under(SlotBtn2)) return 2;
    if (Under(SlotBtn3)) return 3;
    if (Under(SlotBtn4)) return 4;
    return INDEX_NONE;
}

// slot selection
void ULoadoutEditorWidget::OnSlot0(){ SelectedSlot=0; }
void ULoadoutEditorWidget::OnSlot1(){ SelectedSlot=1; }
void ULoadoutEditorWidget::OnSlot2(){ SelectedSlot=2; }
void ULoadoutEditorWidget::OnSlot3(){ SelectedSlot=3; }
void ULoadoutEditorWidget::OnSlot4(){ SelectedSlot=4; }

void ULoadoutEditorWidget::OnSave()
{
    if (Combat) Combat->SetLoadout(EditorLoadout);
    RemoveFromParent();
}

void ULoadoutEditorWidget::OnCancel()
{
    // discard working copy; just close
    RemoveFromParent();
}

void ULoadoutEditorWidget::SetSlotHighlight(int32 Index, bool /*bOn*/)
{
    auto Reset = [&](UButton* Btn, UTextBlock* Txt)
    {
        if (Btn) Btn->SetRenderOpacity(0.8f);
        if (Txt) Txt->SetColorAndOpacity(FSlateColor(FLinearColor::White));
    };
    auto Hi = [&](UButton* Btn, UTextBlock* Txt)
    {
        if (Btn) Btn->SetRenderOpacity(1.0f);
        if (Txt) Txt->SetColorAndOpacity(FSlateColor(FLinearColor::Yellow));
    };

    // reset all
    Reset(SlotBtn0, SlotText0);
    Reset(SlotBtn1, SlotText1);
    Reset(SlotBtn2, SlotText2);
    Reset(SlotBtn3, SlotText3);
    Reset(SlotBtn4, SlotText4);

    // highlight current
    switch (Index)
    {
        case 0: Hi(SlotBtn0, SlotText0); break;
        case 1: Hi(SlotBtn1, SlotText1); break;
        case 2: Hi(SlotBtn2, SlotText2); break;
        case 3: Hi(SlotBtn3, SlotText3); break;
        case 4: Hi(SlotBtn4, SlotText4); break;
        default: break;
    }
}

void ULoadoutEditorWidget::NativeOnDragEnter(const FGeometry& Geo, const FDragDropEvent& Ev, UDragDropOperation* Op)
{
    Super::NativeOnDragEnter(Geo, Ev, Op);
    HoveredSlot = HitTestSlotIndex(Ev.GetScreenSpacePosition());
    SetSlotHighlight(HoveredSlot, true);
    SetSlotsHitTest(false);               // <-- let root receive OnDrop
}

void ULoadoutEditorWidget::NativeOnDragLeave(const FDragDropEvent& Ev, UDragDropOperation* Op)
{
    Super::NativeOnDragLeave(Ev, Op);
    HoveredSlot = INDEX_NONE;
    SetSlotHighlight(INDEX_NONE, false);
    SetSlotsHitTest(true);                // <-- restore
}

bool ULoadoutEditorWidget::NativeOnDragOver(const FGeometry& Geo, const FDragDropEvent& Ev, UDragDropOperation* Op)
{
    const int32 NewIdx = HitTestSlotIndex(Ev.GetScreenSpacePosition());
    if (NewIdx != HoveredSlot)
    {
        HoveredSlot = NewIdx;
        SetSlotHighlight(HoveredSlot, true);
    }
    return true;
}

bool ULoadoutEditorWidget::NativeOnDrop(const FGeometry& Geo, const FDragDropEvent& Ev, UDragDropOperation* Op)
{
    SetSlotsHitTest(true);                // <-- restore
    SetSlotHighlight(INDEX_NONE, false);
    HoveredSlot = INDEX_NONE;

    const int32 Index = HitTestSlotIndex(Ev.GetScreenSpacePosition());
    if (!EditorLoadout.IsValidIndex(Index)) return false;

    if (UActionDragOperation* Drag = Cast<UActionDragOperation>(Op))
    {
        EditorLoadout[Index].Action   = Drag->Action;
        EditorLoadout[Index].SlotCost = 1;
        SelectedSlot = Index;
        RefreshSlots();

        if (UWidget* DV = Cast<UWidget>(Drag->DefaultDragVisual))
            DV->SetVisibility(ESlateVisibility::Visible);
        return true;
    }
    return false;
}


void ULoadoutEditorWidget::SetSlotsHitTest(bool bEnable)
{
    auto Set = [&](UButton* Btn)
    {
        if (!Btn) return;
        Btn->SetVisibility(bEnable ? ESlateVisibility::Visible
                                   : ESlateVisibility::SelfHitTestInvisible);
    };
    Set(SlotBtn0); Set(SlotBtn1); Set(SlotBtn2); Set(SlotBtn3); Set(SlotBtn4);
}


================================================
FILE: Private/PathView.cpp
================================================
#include "PathView.h"
#include "Components/LineBatchComponent.h"

APathView::APathView()
{
	LineBatch = CreateDefaultSubobject<ULineBatchComponent>(TEXT("LineBatch"));
	SetRootComponent(LineBatch);
	SetActorTickEnabled(false);
}

void APathView::BeginPlay()
{
	Super::BeginPlay();
	if (LineBatch) LineBatch->Flush();
}

void APathView::BuildPointsWithOffset(const TArray<FVector>& In, TArray<FVector>& Out) const
{
	Out.Reset(In.Num());
	for (const FVector& P : In)
	{
		FVector Q = P;
		Q.Z += ZOffset;
		Out.Add(Q);
	}
}

void APathView::Clear()
{
	if (!LineBatch) return;
	LineBatch->Flush();              // supprime les lignes existantes
	LineBatch->MarkRenderStateDirty();
}

void APathView::Show(const TArray<FVector>& Points)
{
	if (!LineBatch) return;

	TArray<FVector> P;
	BuildPointsWithOffset(Points, P);

	LineBatch->Flush();
	for (int32 i = 0; i + 1 < P.Num(); ++i)
	{
		LineBatch->DrawLine(P[i], P[i+1], Color, /*DepthPriority*/0, Thickness, LifeTime);
	}
	LineBatch->MarkRenderStateDirty();
}



================================================
FILE: Private/PlayerStatsWidget.cpp
================================================
#include "PlayerStatsWidget.h"
#include "Components/TextBlock.h"
#include "CombatComponent.h"
#include "Engine/World.h"
#include "Components/ProgressBar.h"
#include "TimerManager.h"

UPlayerStatsWidget::UPlayerStatsWidget(const FObjectInitializer& Obj)
    : Super(Obj)
{
    // no ticking here
}

void UPlayerStatsWidget::NativeConstruct()
{
    Super::NativeConstruct();
    RefreshTexts(); // initial fill

    if (UWorld* W = GetWorld())
    {
        W->GetTimerManager().SetTimer(
            RefreshTimer, this, &UPlayerStatsWidget::RefreshTexts,
            0.10f, /*bLoop=*/true
        );
    }
}

void UPlayerStatsWidget::NativeDestruct()
{
    if (UWorld* W = GetWorld())
    {
        W->GetTimerManager().ClearTimer(RefreshTimer);
    }
    Super::NativeDestruct();
}

void UPlayerStatsWidget::RefreshTexts()
{
    if (!Combat) return;
    const auto& S = Combat->GetStats();

    if (HPBar)
    {
        const float pct = (S.MaxHP > 0) ? float(S.HP) / float(S.MaxHP) : 0.f;
        HPBar->SetPercent(pct);
    }

    if (HPText)  HPText->SetText(FText::FromString(FString::Printf(TEXT("HP: %d / %d"), S.HP, S.MaxHP)));
    if (AtkText) AtkText->SetText(FText::FromString(FString::Printf(TEXT("ATK: %d"), S.Attack)));
    if (DefText) DefText->SetText(FText::FromString(FString::Printf(TEXT("DEF: %d"), S.Defense)));
    if (XpText)  XpText->SetText(FText::FromString(FString::Printf(TEXT("XP: %d / %d"), S.XP, S.XPToNext)));
    if (LvlText) LvlText->SetText(FText::FromString(FString::Printf(TEXT("LVL: %d"), S.Level)));
}


================================================
FILE: Public/ActionDragOperation.h
================================================
#pragma once
#include "Blueprint/DragDropOperation.h"
#include "BattleActions.h"
#include "ActionDragOperation.generated.h"

UCLASS()
class DEMO_API UActionDragOperation : public UDragDropOperation
{
    GENERATED_BODY()
public:
    UPROPERTY(BlueprintReadWrite)
    EBattleAction Action = EBattleAction::None;
};



================================================
FILE: Public/ActionEntryWidget.h
================================================
#pragma once
#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "BattleActions.h"
#include "Blueprint/DragDropOperation.h"
#include "ActionEntryWidget.generated.h"

class UTextBlock;

UCLASS()
class DEMO_API UActionEntryWidget : public UUserWidget
{
	GENERATED_BODY()
public:
	UActionEntryWidget(const FObjectInitializer &);

	UFUNCTION(BlueprintCallable, Category = "Battle")
	void SetAction(EBattleAction In)
	{
		Action = In;
		RefreshLabel();
	}

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Battle")
	EBattleAction DefaultAction = EBattleAction::None; // set in BP if desired

protected:
	virtual void NativeConstruct() override;
	virtual FReply NativeOnPreviewMouseButtonDown(const FGeometry &, const FPointerEvent &) override;
	virtual void NativeOnDragDetected(const FGeometry &Geo, const FPointerEvent &MouseEvent, UDragDropOperation *&OutOp) override;
	virtual void NativeOnDragCancelled(const FDragDropEvent &Ev, UDragDropOperation *Op) override;
	virtual bool NativeOnDrop(const FGeometry &Geo, const FDragDropEvent &Ev, UDragDropOperation *Op) override;

private:
	void RefreshLabel();

private:
	UPROPERTY()
	EBattleAction Action = EBattleAction::None;

public: // BindWidget
	UPROPERTY(meta = (BindWidget))
	UTextBlock *Label = nullptr;
};



================================================
FILE: Public/BattleActions.h
================================================
#pragma once
#include "Kismet/BlueprintFunctionLibrary.h"
#include "BattleActions.generated.h"

UENUM(BlueprintType)
enum class EBattleAction : uint8
{
    None   UMETA(DisplayName="None"),
    Attack UMETA(DisplayName="Attack"),
    Heal   UMETA(DisplayName="Heal"),
    // add more later
};

USTRUCT(BlueprintType)
struct FBattleActionSlot
{
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Battle")
    EBattleAction Action = EBattleAction::None;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Battle")
    int32 SlotCost = 1; // future-proof (multi-slot actions)
};

UCLASS()
class DEMO_API UBattleActionLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()
public:
    UFUNCTION(BlueprintPure, Category="Battle")
    static FText ActionToText(EBattleAction A)
    {
        switch (A)
        {
            case EBattleAction::Attack: return FText::FromString(TEXT("Attack"));
            case EBattleAction::Heal:   return FText::FromString(TEXT("Heal"));
            default:                    return FText::FromString(TEXT("-"));
        }
    }
};



================================================
FILE: Public/BattleWidget.h
================================================
#pragma once
#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "BattleActions.h"
#include "BattleWidget.generated.h"

class UImage;
class UProgressBar;
class UTextBlock;
class UButton;
class UCombatComponent;
class UTexture2D;
class UCanvasPanel;
class UFloatingTextWidget;
class UWidgetAnimation;

UCLASS()
class DEMO_API UBattleWidget : public UUserWidget
{
    GENERATED_BODY()

public:
    UBattleWidget(const FObjectInitializer&);

    UFUNCTION(BlueprintCallable, Category="Battle")
    void SetSides(UCombatComponent* InPlayer, UCombatComponent* InEnemy);

    UFUNCTION(BlueprintCallable, Category="Battle")
    void SetEnemyPortrait(UTexture2D* Tex);

    UFUNCTION(BlueprintCallable, Category="Battle")
    void SetPlayerPortrait(UTexture2D* Tex);

    UFUNCTION(BlueprintCallable, Category="Battle")
    void StartAutoBattle();

    UFUNCTION(BlueprintCallable, Category="Battle")
    void StopAutoBattle();

    UFUNCTION(BlueprintCallable, Category="Battle")
    void SetVictoryXP(int32 InXP) { VictoryXP = FMath::Max(0, InXP); }

protected:
    virtual void NativeConstruct() override;
    virtual void NativeDestruct() override;

private:
    void Refresh();
    void UpdateHighlights();
    void StepAction();
    void DoAction(UCombatComponent *Source, UCombatComponent *Target, const FBattleActionSlot &ActionSlot);
    
    void SpawnFloat(bool bOnEnemy, const FText &T, const FLinearColor &Color);
    void PlayHitWiggle(bool bOnEnemy);
    void UpdateDeathMasks();
    void GrantVictoryXP();

    UTextBlock *PlayerActTextAt(int32 Index) const;
    UTextBlock *EnemyActTextAt(int32 Index) const;

    UFUNCTION()
    void OnQuitClicked();

private:
    FTimerHandle RefreshTimer;
    FTimerHandle ActionTimer;

    UPROPERTY() UCombatComponent* PlayerCombat = nullptr;
    UPROPERTY() UCombatComponent* EnemyCombat  = nullptr;

    int32  CurrentIndex = 0;
    bool   bBattleRunning = false;
    bool   bPlayerTurn    = true;
    bool   bHighlightPlayerTurn = true;
    int32  HL_Player = INDEX_NONE;
    int32  HL_Enemy  = INDEX_NONE;

    int32  VictoryXP  = 0;
    bool   bXPGranted = false;

public: // Widgets
    // Player actions
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock* PlayerAct0 = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock* PlayerAct1 = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock* PlayerAct2 = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock* PlayerAct3 = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock* PlayerAct4 = nullptr;

    // Enemy actions
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock* EnemyAct0 = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock* EnemyAct1 = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock* EnemyAct2 = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock* EnemyAct3 = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock* EnemyAct4 = nullptr;

    // Portraits
    UPROPERTY(meta=(BindWidgetOptional)) UImage* PlayerPortrait = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UImage* EnemyPortrait  = nullptr;

    // HP
    UPROPERTY(meta=(BindWidgetOptional)) UProgressBar* PlayerHPBar  = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock*   PlayerHPText = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UProgressBar* EnemyHPBar   = nullptr;
    UPROPERTY(meta=(BindWidgetOptional)) UTextBlock*   EnemyHPText  = nullptr;

    // Quit
    UPROPERTY(meta=(BindWidget)) UButton* BtnQuit = nullptr;

    // FX
    UPROPERTY(EditAnywhere, Category="Battle|FX") TSubclassOf<UFloatingTextWidget> FloatingTextClass;
    UPROPERTY(meta=(BindWidget)) UCanvasPanel* PlayerFXLayer = nullptr;
    UPROPERTY(meta=(BindWidget)) UCanvasPanel* EnemyFXLayer  = nullptr;
    UPROPERTY(Transient, meta=(BindWidgetAnimOptional)) UWidgetAnimation* PlayerHit = nullptr;
    UPROPERTY(Transient, meta=(BindWidgetAnimOptional)) UWidgetAnimation* EnemyHit  = nullptr;
    UPROPERTY(meta=(BindWidget)) UImage* PlayerDeathMask = nullptr;
    UPROPERTY(meta=(BindWidget)) UImage* EnemyDeathMask  = nullptr;
};



================================================
FILE: Public/CombatComponent.h
================================================
#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "BattleActions.h"

#include "CombatComponent.generated.h"

USTRUCT(BlueprintType)
struct FCombatStats
{
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Combat")
    int32 Level = 1;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Combat")
    int32 HP = 20;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Combat")
    int32 MaxHP = 20;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Combat")
    int32 Attack = 5;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Combat")
    int32 Defense = 2;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Combat")
    int32 XP = 0;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Combat")
    int32 XPToNext = 100;
};

UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class DEMO_API UCombatComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    UCombatComponent();

    UFUNCTION(BlueprintCallable, Category="Combat")
    const FCombatStats& GetStats() const { return Stats; }

    UFUNCTION(BlueprintCallable, Category="Combat") void AddXP(int32 Amount);
    UFUNCTION(BlueprintCallable, Category="Combat") void ApplyDamage(int32 RawDamage);
    UFUNCTION(BlueprintCallable, Category="Combat") void Heal(int32 Amount);

	UFUNCTION(BlueprintPure, Category="Battle") int32 GetMaxSlots() const { return MaxSlots; }
    UFUNCTION(BlueprintPure, Category="Battle") const TArray<FBattleActionSlot>& GetLoadout() const { return Loadout; }
    UFUNCTION(BlueprintCallable, Category="Battle") void SetSlotAction(int32 Index, EBattleAction Action, int32 Cost = 1);
	UFUNCTION(BlueprintCallable, Category="Battle") void SetLoadout(const TArray<FBattleActionSlot>& In);
    UFUNCTION(BlueprintCallable, Category="Combat") void SetStats(const FCombatStats& In) { Stats = In; Stats.HP = FMath::Clamp(Stats.HP, 0, Stats.MaxHP); }

protected:
    virtual void BeginPlay() override;  // <-- add this

private:
    void TryLevelUp();

    UPROPERTY(EditDefaultsOnly, Category="Combat")
    FCombatStats Stats;

	UPROPERTY(EditAnywhere, Category="Battle")
    int32 MaxSlots = 5;

    UPROPERTY(EditAnywhere, Category="Battle")
    TArray<FBattleActionSlot> Loadout;
};



================================================
FILE: Public/DemoGameMode.h
================================================
// DemoGameMode.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/GameModeBase.h"
#include "HexCoordinates.h"
#include "Blueprint/UserWidget.h" // add (or: forward declare class UUserWidget;)
#include "DemoGameMode.generated.h"

// Forward declarations
class UUserWidget;
class AHexTile;
class UHexGridManager;
class UHexPathFinder;
class APathView;
class AHexPawn;
class AHexAnimationManager;
class UPlayerStatsWidget;
class UBattleWidget;
class ULoadoutEditorWidget;
class UEnemyDefinition;
class AHexEnemyPawn;
/**
 * Central GameMode: owns GridManager and PathFinder, drives click-to-move and path preview.
 */
UCLASS()
class DEMO_API ADemoGameMode : public AGameModeBase
{
    GENERATED_BODY()

public:
    ADemoGameMode();

    /** Click handler entry point from tiles */
    UFUNCTION(BlueprintCallable, Category = "Hex|Input")
    void HandleTileClicked(AHexTile *ClickedTile);

    /** Accessors for managers */
    UFUNCTION(BlueprintPure, Category = "Hex")
    UHexGridManager *GetHexGridManager() const { return GridManager; }

    UFUNCTION(BlueprintPure, Category = "Hex")
    UHexPathFinder *GetHexPathFinder() const { return PathFinder; }

    /** Planned-path rendering */
    UFUNCTION(BlueprintCallable, Category = "Hex|Path")
    void ShowPlannedPathTo(AHexTile *GoalTile);

    UFUNCTION(BlueprintCallable, Category = "Hex|Path")
    void ClearPlannedPath();

    /** Hover preview controls */
    void PreviewPathTo(AHexTile *GoalTile);
    void ClearPreview();

    UFUNCTION(BlueprintCallable, Category = "Hex|PathPreview")
    void SetPreviewEnabled(bool bEnabled);

    UFUNCTION(BlueprintCallable, Category = "Hex|PathPreview")
    void TogglePreview();

    UFUNCTION(BlueprintPure, Category = "Hex|PathPreview")
    bool IsPreviewEnabled() const { return bPreviewEnabled; }

    /** Open shop UI at a given tile */
    UFUNCTION(BlueprintCallable, Category = "Hex|Gameplay")
    void OpenShopAt(AHexTile *ShopTile);

    /** Initial axial coordinates for the player pawn */
    UPROPERTY(EditAnywhere, Category = "Hex|Start")
    FHexAxialCoordinates StartCoords = FHexAxialCoordinates(0, 6);

    UFUNCTION(BlueprintCallable, Category = "Hex|Visibility")
    void UpdateReachableVisibility(int32 MaxSteps);

    UPROPERTY(EditAnywhere, Category = "UI")
    TSubclassOf<UUserWidget> PlayerStatsWidgetClass;

    UFUNCTION(BlueprintCallable, Category = "Battle")
    void StartTestBattle();

    UPROPERTY(EditAnywhere, Category = "UI")
    TSubclassOf<UUserWidget> BattleWidgetClass;

    UPROPERTY(EditAnywhere, Category = "UI")
    TSubclassOf<UUserWidget> LoadoutWidgetClass;

    UPROPERTY(EditAnywhere, Category="Battle")
    TMap<FName, TSoftObjectPtr<UEnemyDefinition>> EnemyCatalog;

    UPROPERTY(EditAnywhere, Category = "Battle")
    TSubclassOf<AHexEnemyPawn> EnemyPawnClass;

    UFUNCTION(BlueprintCallable, Category = "Battle")
    void OpenLoadoutEditor();

    UFUNCTION() void OnPawnArrived(AHexPawn* Pawn);

        
protected:
    /** Engine lifecycle */
    virtual void BeginPlay() override;
    virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;

    /** Post-login hooks to finish initial snapping */
    virtual void PostLogin(APlayerController *NewPlayer) override;
    virtual void Logout(AController *Exiting) override;

    /** Position the pawn on the starting tile */
    void InitializePawnStartTile(const FHexAxialCoordinates &InStartCoords);

    /** Tile class used to spawn the grid */
    UPROPERTY(EditAnywhere, Category="Hex|Grid")
    TSubclassOf<class AHexTile> HexTileClass;

    /** Grid generation parameters */
    UPROPERTY(EditDefaultsOnly, Category = "Hex")
    int32 GridRadius = 10;

    /** Core managers (created/owned by GM) */
    UPROPERTY(VisibleAnywhere, Category = "Hex")
    UHexGridManager *GridManager = nullptr;

    UPROPERTY(VisibleAnywhere, Category = "Hex")
    UHexPathFinder *PathFinder = nullptr;

    /** Path debug actor */
    UPROPERTY()
    APathView *PathView = nullptr;

    /** Optional: UI class for shop */
    UPROPERTY(EditDefaultsOnly, Category = "UI")
    TSubclassOf<UUserWidget> ShopWidgetClass;

    /** Optional PC override through BP */
    UPROPERTY(EditDefaultsOnly, Category = "Player")
    TSoftClassPtr<APlayerController> PCClassSoft;

    /** Optional animation manager */
    UPROPERTY()
    AHexAnimationManager *AnimationManager = nullptr;

private:
    /** Preview throttle */
    FTimerHandle PreviewThrottle;

    /** Hover target and caching to avoid recompute */
    TWeakObjectPtr<AHexTile> PendingGoal;
    FHexAxialCoordinates LastStart{INT32_MAX, INT32_MAX};
    FHexAxialCoordinates LastGoal{INT32_MAX, INT32_MAX};

    /** Keep a weak ref to shop widget to avoid double-destroy */
    UPROPERTY()
    TWeakObjectPtr<UUserWidget> ShopWidget;

    /** Periodic preview update */
    void DoPreviewTick();

    /** Typed pawn getter */
    AHexPawn *GetPlayerPawnTyped() const;

    /** Preview toggle */
    UPROPERTY(EditAnywhere, Category = "Hex|PathPreview")
    bool bPreviewEnabled = true;

    /** Post-login pawn snap retry */
    FTimerHandle SnapRetryHandle;

    /** Try to snap pawn and camera to the start tile */
    UFUNCTION()
    void TrySnapPawnOnce();

    TWeakObjectPtr<UUserWidget> PlayerStatsWidget;
    TWeakObjectPtr<UBattleWidget> BattleWidget;

    FRandomStream EnemyRNG;
    FName PickRandomEnemyIdFromCatalog() const;
};



================================================
FILE: Public/EnemyDefinition.h
================================================
#pragma once
#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "CombatComponent.h"
#include "BattleActions.h"                 // <- for FBattleActionSlot
#include "EnemyDefinition.generated.h"

class UTexture2D;

UCLASS(BlueprintType)
class DEMO_API UEnemyDefinition : public UDataAsset
{
    GENERATED_BODY()
public:
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Enemy") FName EnemyId;
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Enemy") FText DisplayName;
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Enemy") TSoftObjectPtr<UTexture2D> Portrait;
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Enemy") FCombatStats BaseStats;
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Enemy") int32 XPReward = 10;

    // NEW: action slots (size = 5 for now)
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Enemy")
    TArray<FBattleActionSlot> Loadout;
};



================================================
FILE: Public/FloatingTextWidget.h
================================================
#pragma once
#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "FloatingTextWidget.generated.h"

class UTextBlock;
class UWidgetAnimation;

UCLASS()
class DEMO_API UFloatingTextWidget : public UUserWidget
{
    GENERATED_BODY()
public:
    UPROPERTY(meta=(BindWidget)) UTextBlock* Label = nullptr;
    UPROPERTY(Transient, meta=(BindWidgetAnim)) UWidgetAnimation* Pop = nullptr;

    UFUNCTION(BlueprintCallable) void SetTextAndColor(const FText& T, const FLinearColor& C);
    void PlayAndDie();

private:
    UFUNCTION() void OnAnimFinished();
};



================================================
FILE: Public/HexAnimationManager.h
================================================
// HexAnimationManager.h - Add at the top after includes
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "HexAnimationManager.generated.h"

// Forward declaration
class AHexPawn;

// HexAnimationManager.h - Manages all player animations efficiently
UCLASS()
class DEMO_API AHexAnimationManager : public AActor
{
    GENERATED_BODY()

public:
    AHexAnimationManager();

    // Player registry
    void RegisterPlayer(AHexPawn *Pawn);
    void UnregisterPlayer(AHexPawn *Pawn);

    // Batch updates for performance
    UFUNCTION(BlueprintCallable, Category = "Animation")
    void BatchUpdateAnimations();

    // Animation pooling for multiple players
    UPROPERTY(EditAnywhere, Category = "Animation")
    TMap<FString, class UPaperFlipbook *> SharedAnimationPool;

protected:
    // Separate lists for optimization
    UPROPERTY()
    TArray<TWeakObjectPtr<AHexPawn>> LocalPlayers;

    UPROPERTY()
    TArray<TWeakObjectPtr<AHexPawn>> RemotePlayers;

    // Update frequencies
    UPROPERTY(EditAnywhere, Category = "Performance")
    float LocalPlayerUpdateRate = 0.016f; // 60 FPS

    UPROPERTY(EditAnywhere, Category = "Performance")
    float RemotePlayerUpdateRate = 0.033f; // 30 FPS

private:
    float LocalUpdateAccumulator = 0.0f;
    float RemoteUpdateAccumulator = 0.0f;
};


================================================
FILE: Public/HexAnimationTypes.h
================================================
// Public/HexAnimationTypes.h
#pragma once

#include "CoreMinimal.h"
#include "HexAnimationTypes.generated.h"

// Animation states enum (shared across the project)
UENUM(BlueprintType)
enum class EHexAnimState : uint8
{
    Idle        = 0 UMETA(DisplayName="Idle"),
    Walking     = 1 UMETA(DisplayName="Walking"),
    Attacking   = 2 UMETA(DisplayName="Attacking"),
    Damaged     = 3 UMETA(DisplayName="Damaged"),
    Dead        = 4 UMETA(DisplayName="Dead"),
    Interacting = 5 UMETA(DisplayName="Interacting"),
    Casting     = 6 UMETA(DisplayName="Casting"),
    MAX         = 7 UMETA(Hidden)
};

// Compressed state for network replication
USTRUCT(BlueprintType)
struct DEMO_API FCompressedAnimState
{
    GENERATED_BODY()

    uint8 AnimState : 3;      // 0-7 states
    uint8 FacingDir : 3;      // 0-7 directions  
    uint8 IsMoving : 1;       // Moving flag
    uint8 IsCombat : 1;       // Combat flag

    FCompressedAnimState()
    {
        AnimState = 0;
        FacingDir = 0;
        IsMoving = 0;
        IsCombat = 0;
    }

    // Helper functions
    void SetAnimState(EHexAnimState State) 
    { 
        AnimState = (uint8)State; 
    }
    
    EHexAnimState GetAnimState() const 
    { 
        return (EHexAnimState)AnimState; 
    }

    // Network serialization
    bool NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess)
    {
        uint8 Packed = (AnimState << 5) | (FacingDir << 2) | (IsMoving << 1) | IsCombat;
        Ar.SerializeBits(&Packed, 8);
        if (Ar.IsLoading())
        {
            AnimState = (Packed >> 5) & 0x07;
            FacingDir = (Packed >> 2) & 0x07;
            IsMoving = (Packed >> 1) & 0x01;
            IsCombat = Packed & 0x01;
        }
        bOutSuccess = true;
        return true;
    }
};

// Must tell Unreal this struct can be serialized
template<>
struct TStructOpsTypeTraits<FCompressedAnimState> : public TStructOpsTypeTraitsBase2<FCompressedAnimState>
{
    enum
    {
        WithNetSerializer = true,
    };
};

// Full animation state (for local use, not compressed)
USTRUCT(BlueprintType)
struct DEMO_API FHexAnimationState
{
    GENERATED_BODY()

    UPROPERTY(BlueprintReadWrite, Category="Animation")
    EHexAnimState CurrentState = EHexAnimState::Idle;

    UPROPERTY(BlueprintReadWrite, Category="Animation")
    float StateStartTime = 0.0f;

    UPROPERTY(BlueprintReadWrite, Category="Animation")
    int32 FacingDirection = 0;

    UPROPERTY(BlueprintReadWrite, Category="Animation")
    bool bIsMoving = false;

    // Convert to compressed for network
    FCompressedAnimState Compress() const
    {
        FCompressedAnimState Compressed;
        Compressed.SetAnimState(CurrentState);
        Compressed.FacingDir = FMath::Clamp(FacingDirection, 0, 7);
        Compressed.IsMoving = bIsMoving ? 1 : 0;
        Compressed.IsCombat = (CurrentState == EHexAnimState::Attacking) ? 1 : 0;
        return Compressed;
    }
};


================================================
FILE: Public/HexCoordinates.h
================================================
#pragma once

#include "CoreMinimal.h"
#include "HexCoordinates.generated.h"

USTRUCT(BlueprintType)
struct DEMO_API FHexAxialCoordinates
{
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Hex")
    int32 Q = 0;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Hex")
    int32 R = 0;

    FHexAxialCoordinates() = default;
    FHexAxialCoordinates(int32 InQ, int32 InR) : Q(InQ), R(InR) {}

    // opÃ©rateur == nÃ©cessaire pour TMap.Find(...)
    bool operator==(const FHexAxialCoordinates& Other) const
    {
        return Q == Other.Q && R == Other.R;
    }

    // distance hexagonale Â« manhattan Â» (axial coords)
    int32 DistanceTo(const FHexAxialCoordinates& Other) const
    {
        const int32 dQ = FMath::Abs(Q - Other.Q);
        const int32 dR = FMath::Abs(R - Other.R);
        const int32 dS = FMath::Abs((Q + R) - (Other.Q + Other.R));
        return (dQ + dR + dS) / 2;
    }
};

// hash pour le TMap
FORCEINLINE uint32 GetTypeHash(const FHexAxialCoordinates& Coords)
{
    return HashCombine(::GetTypeHash(Coords.Q), ::GetTypeHash(Coords.R));
}



================================================
FILE: Public/HexEnemyPawn.h
================================================
#pragma once
#include "CoreMinimal.h"
#include "HexPawn.h"
#include "HexEnemyPawn.generated.h"

class UEnemyDefinition;

UCLASS()
class DEMO_API AHexEnemyPawn : public AHexPawn
{
    GENERATED_BODY()
public:
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Enemy")
    TSoftObjectPtr<UEnemyDefinition> EnemyData;

protected:
    virtual void BeginPlay() override;
	AHexEnemyPawn();
};



================================================
FILE: Public/HexGridManager.h
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x9d in position 2469: character maps to <undefined>


================================================
FILE: Public/HexPathFinder.h
================================================
#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "HexCoordinates.h"
#include "HexPathFinder.generated.h"

class UHexGridManager;

/** A* sur grille hex (doubled-q), voisins = tuiles rÃ©ellement prÃ©sentes. */
UCLASS(ClassGroup=(Hex), meta=(BlueprintSpawnableComponent))
class DEMO_API UHexPathFinder : public UActorComponent
{
	GENERATED_BODY()

public:
	UHexPathFinder();

	/** Ã€ appeler au BeginPlay du GM : PathFinder->Init(GridManager); */
	UFUNCTION(BlueprintCallable, Category="Hex|Path")
	void Init(UHexGridManager* InGrid) { GridRef = InGrid; }

	/** Trouve un chemin Start->Goal (Start et Goal inclus). Vide si impossible. */
	UFUNCTION(BlueprintCallable, Category="Hex|Path")
	TArray<FHexAxialCoordinates> FindPath(const FHexAxialCoordinates& Start,
	                                      const FHexAxialCoordinates& Goal);

private:
	UPROPERTY() UHexGridManager* GridRef = nullptr;

	void GetValidNeighbors(const FHexAxialCoordinates& From,
	                       TArray<FHexAxialCoordinates>& Out) const;

	int32 Heuristic(const FHexAxialCoordinates& A, const FHexAxialCoordinates& B) const;

	static void ReconstructPath(const TMap<FHexAxialCoordinates,FHexAxialCoordinates>& Parent,
	                            const FHexAxialCoordinates& Start,
	                            const FHexAxialCoordinates& Goal,
	                            TArray<FHexAxialCoordinates>& OutPath);
};



================================================
FILE: Public/HexPawn.h
================================================
// HexPawn.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Pawn.h"
#include "HexCoordinates.h"
#include "HexAnimationTypes.h"
#include "CombatComponent.h" 
#include "HexPawn.generated.h"

// Forward declarations
class USpringArmComponent;
class UCameraComponent;
class UHexSpriteComponent;
class AHexTile;
class UHexGridManager;
class UCombatComponent;

/**
 * Pawn that moves tile-to-tile on a hex grid and displays a Paper2D flipbook.
 * Server drives movement. Clients mirror sprite orientation locally.
 */
UCLASS()
class DEMO_API AHexPawn : public APawn
{
    GENERATED_BODY()

public:
    AHexPawn();

    /** Engine lifecycle */
    virtual void BeginPlay() override;
    virtual void Tick(float DeltaTime) override;

    /** Start following a path of axial coordinates on a given grid */
    UFUNCTION(BlueprintCallable, Category="Hex|Move")
    void StartPathFollowing(const TArray<FHexAxialCoordinates>& InPath, UHexGridManager* InGridManager);

    /** Set current tile reference (no teleport unless done by caller) */
    UFUNCTION(BlueprintCallable, Category="Hex|Move")
    void SetCurrentTile(AHexTile* NewTile);

    /** Get current tile */
    UFUNCTION(BlueprintPure, Category="Hex|Move")
    AHexTile* GetCurrentTile() const { return CurrentTile; }

    /** Snap pawn to a start tile by axial coordinates */
    UFUNCTION(BlueprintCallable, Category="Hex|Move")
    void InitializePawnStartTile(const FHexAxialCoordinates& StartCoords);

    /** Camera tuning */
    UPROPERTY(EditAnywhere, Category="Camera", meta=(ClampMin="100.0"))
    float CameraHeight = 1500.f;

    /** Rotate toward movement direction (disabled by default) */
    UPROPERTY(EditAnywhere, Category="Hex|Move")
    bool bFaceDirection = false;

    /** Time to traverse one step between adjacent tiles */
    UPROPERTY(EditAnywhere, Category="Hex|Move", meta=(ClampMin="0.05"))
    float StepDuration = 0.2f;

    /** Smoothstep easing for movement */
    UPROPERTY(EditAnywhere, Category="Hex|Move")
    bool bEaseInOut = true;

    /** Yaw turn rate when bFaceDirection = true */
    UPROPERTY(EditAnywhere, Category="Hex|Move", meta=(ClampMin="0.0"))
    float TurnRateDegPerSec = 720.f;

    /** Replication setup */
    virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

    /** Path replicated from server to clients */
    UPROPERTY(ReplicatedUsing=OnRep_CurrentPath)
    TArray<FHexAxialCoordinates> ReplicatedPath;

    /** Client hook when ReplicatedPath updates */
    UFUNCTION()
    void OnRep_CurrentPath();

    /** Server RPC to request movement */
    UFUNCTION(Server, Reliable)
    void ServerRequestMove(const TArray<FHexAxialCoordinates>& NewPath);

    /** Optional network smoothing (reserved for future use) */
    UPROPERTY(EditAnywhere, Category="Network")
    bool bUseSmoothingForRemotePlayers = true;

    UPROPERTY(EditAnywhere, Category="Network", meta=(ClampMin="0.0", ClampMax="1.0"))
    float NetworkSmoothingRate = 0.1f;

    /** Paper2D sprite component wrapper */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Hex|Visual")
    UHexSpriteComponent* SpriteComp = nullptr;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Combat")
    UCombatComponent* Combat = nullptr;

    UFUNCTION(BlueprintPure, Category="Combat")
    UCombatComponent* GetCombat() const { return Combat; }

protected:
    /** Local/remote hooks (no-op for now) */
    void TickLocalPlayer(float /*DeltaTime*/) {}
    void TickRemotePlayer(float /*DeltaTime*/) {}

    /** Possession hooks keep camera locked on pawn */
    virtual void PossessedBy(AController* NewController) override;
    virtual void OnRep_Controller() override;

private:
    /** Camera rig */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Camera", meta=(AllowPrivateAccess="true"))
    USpringArmComponent* CameraBoom = nullptr;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Camera", meta=(AllowPrivateAccess="true"))
    UCameraComponent* TopDownCamera = nullptr;

    /** Grid and movement state */
    UPROPERTY()
    UHexGridManager* GridRef = nullptr;

    UPROPERTY()
    TArray<FHexAxialCoordinates> CurrentPath;

    int32  CurrentStepIndex = 0;
    bool   bIsMoving = false;
    float  StepElapsed = 0.f;

    FVector StartLocation;
    FVector TargetLocation;

    UPROPERTY()
    AHexTile* CurrentTile = nullptr;

    FVector LastReplicatedLocation;
    FVector SmoothLocation;

    /** Sprite mirroring state */
    UPROPERTY()
    FVector SpriteBaseScale = FVector(1,1,1);

    /** Flip the sprite horizontally relative to camera right vs. move direction */
    void UpdateSpriteMirrorToward(const FVector& From, const FVector& To);
};



================================================
FILE: Public/HexSpriteComponent.h
================================================
#pragma once

#include "CoreMinimal.h"
#include "PaperFlipbookComponent.h"
#include "HexAnimationTypes.h"
#include "PaperFlipbook.h" // en haut
#include "HexSpriteComponent.generated.h"


UCLASS(ClassGroup=(Paper2D), meta=(BlueprintSpawnableComponent))
class DEMO_API UHexSpriteComponent : public UPaperFlipbookComponent
{
    GENERATED_BODY()
public:
    UHexSpriteComponent();

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Hex|Anim") UPaperFlipbook* IdleAnim;

    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Hex|Anim") UPaperFlipbook* WalkAnim;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, ReplicatedUsing=OnRep_AnimState, Category="Hex|Anim")
    EHexAnimState CurrentAnimState = EHexAnimState::Idle;

    UFUNCTION(BlueprintCallable, Category="Hex|Anim")
    void SetAnimationState(EHexAnimState NewState);

protected:
    UFUNCTION()
    void OnRep_AnimState();

    virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

private:
    void ApplyAnim(); // choisit le bon flipbook selon CurrentAnimState
};



================================================
FILE: Public/HexTile.h
================================================
Error reading file with 'cp1252': 'charmap' codec can't decode byte 0x90 in position 4126: character maps to <undefined>


================================================
FILE: Public/LoadoutEditorWidget.h
================================================
#pragma once
#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "BattleActions.h"
#include "LoadoutEditorWidget.generated.h"

class UButton;
class UTextBlock;
class UCombatComponent;

UCLASS()
class DEMO_API ULoadoutEditorWidget : public UUserWidget
{
    GENERATED_BODY()

public:
    ULoadoutEditorWidget(const FObjectInitializer&);
    UFUNCTION(BlueprintCallable, Category="Battle") void SetCombat(UCombatComponent* InCombat);

protected:
    virtual void NativeConstruct() override;
    virtual bool NativeOnDrop(const FGeometry& Geo, const FDragDropEvent& DragDropEvent, UDragDropOperation* Op) override;
    virtual void NativeOnDragEnter(const FGeometry& Geo, const FDragDropEvent& Ev, UDragDropOperation* Op) override;
    virtual void NativeOnDragLeave(const FDragDropEvent& Ev, UDragDropOperation* Op) override;
    virtual bool NativeOnDragOver (const FGeometry& Geo, const FDragDropEvent& Ev, UDragDropOperation* Op) override;

private:
    void RefreshSlots();
    int32 HitTestSlotIndex(const FVector2D& ScreenPos) const; // which slot rect under cursor

    // slot clicks still supported
    UFUNCTION() void OnSlot0(); UFUNCTION() void OnSlot1(); UFUNCTION() void OnSlot2(); UFUNCTION() void OnSlot3(); UFUNCTION() void OnSlot4();
    UFUNCTION() void OnSave();  UFUNCTION() void OnCancel();

private:
    UPROPERTY() UCombatComponent* Combat = nullptr;
    int32 SelectedSlot = 0;

    // working copy so Cancel can revert
    TArray<FBattleActionSlot> OriginalLoadout;
    TArray<FBattleActionSlot> EditorLoadout;

    int32 HoveredSlot = INDEX_NONE;
    void SetSlotHighlight(int32 Index, bool bOn);
    void SetSlotsHitTest(bool bEnable);

public: // BindWidget â€” left column
    UPROPERTY(meta=(BindWidget)) UButton*    SlotBtn0 = nullptr; UPROPERTY(meta=(BindWidget)) UTextBlock* SlotText0 = nullptr;
    UPROPERTY(meta=(BindWidget)) UButton*    SlotBtn1 = nullptr; UPROPERTY(meta=(BindWidget)) UTextBlock* SlotText1 = nullptr;
    UPROPERTY(meta=(BindWidget)) UButton*    SlotBtn2 = nullptr; UPROPERTY(meta=(BindWidget)) UTextBlock* SlotText2 = nullptr;
    UPROPERTY(meta=(BindWidget)) UButton*    SlotBtn3 = nullptr; UPROPERTY(meta=(BindWidget)) UTextBlock* SlotText3 = nullptr;
    UPROPERTY(meta=(BindWidget)) UButton*    SlotBtn4 = nullptr; UPROPERTY(meta=(BindWidget)) UTextBlock* SlotText4 = nullptr;

public: // BindWidget â€” right panel actions (replace your old buttons with ActionEntryWidget instances)
    UPROPERTY(meta=(BindWidget)) class UActionEntryWidget* ActAttack = nullptr;
    UPROPERTY(meta=(BindWidget)) class UActionEntryWidget* ActHeal   = nullptr;

public: // BindWidget â€” footer
    UPROPERTY(meta=(BindWidget)) UButton* BtnSave = nullptr;
    UPROPERTY(meta=(BindWidget)) UButton* BtnCancel = nullptr;
};



================================================
FILE: Public/PathView.h
================================================
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "PathView.generated.h"

class ULineBatchComponent;

UCLASS()
class DEMO_API APathView : public AActor
{
	GENERATED_BODY()

public:
	APathView();

	// Dessine des segments entre Points (ordre donnÃ©)
	UFUNCTION(BlueprintCallable, Category="PathView")
	void Show(const TArray<FVector>& Points);

	// Efface tout
	UFUNCTION(BlueprintCallable, Category="PathView")
	void Clear();

	// Couleur et Ã©paisseur des lignes
	UPROPERTY(EditAnywhere, Category="PathView")
	FLinearColor Color = FLinearColor::Red;

	UPROPERTY(EditAnywhere, Category="PathView", meta=(ClampMin="1.0"))
	float Thickness = 6.f;

	// DÃ©calage Z pour Ã©viter le z-fighting
	UPROPERTY(EditAnywhere, Category="PathView")
	float ZOffset = 2.f;

	// DurÃ©e dâ€™affichage. 0 = une frame. Mettre grand si persistant
	UPROPERTY(EditAnywhere, Category="PathView")
	float LifeTime = 1e6f;

protected:
	virtual void BeginPlay() override;

private:
	UPROPERTY(VisibleAnywhere, Category="PathView")
	ULineBatchComponent* LineBatch = nullptr;

	// Copie Points en ajoutant le ZOffset
	void BuildPointsWithOffset(const TArray<FVector>& In, TArray<FVector>& Out) const;
};



================================================
FILE: Public/PlayerStatsWidget.h
================================================
#pragma once
#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "Components/ProgressBar.h" 
#include "PlayerStatsWidget.generated.h"

class UTextBlock;
class UCombatComponent;

UCLASS()
class DEMO_API UPlayerStatsWidget : public UUserWidget
{
    GENERATED_BODY()

public: // binding
	UPlayerStatsWidget(const FObjectInitializer& Obj);

    UFUNCTION(BlueprintCallable, Category="Combat")
    void SetCombat(UCombatComponent* InCombat) { Combat = InCombat; RefreshTexts(); }

protected: // UUserWidget
    virtual void NativeConstruct() override;
    virtual void NativeDestruct() override;

private: // helpers
    void RefreshTexts();
    FTimerHandle RefreshTimer;

private: // data source
    UPROPERTY()
    UCombatComponent* Combat = nullptr;

public: // BindWidget references (create in BP)
    UPROPERTY(meta=(BindWidget)) UTextBlock* HPText = nullptr;
    UPROPERTY(meta=(BindWidget)) UTextBlock* AtkText = nullptr;
    UPROPERTY(meta=(BindWidget)) UTextBlock* DefText = nullptr;
    UPROPERTY(meta=(BindWidget)) UTextBlock* XpText = nullptr;
    UPROPERTY(meta=(BindWidget)) UTextBlock* LvlText = nullptr;
    UPROPERTY(meta=(BindWidget)) class UProgressBar* HPBar = nullptr;
};


